<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bandicoot CDR Visualization</title>

  <!-- ============================================================
       SECTION: External Dependencies (CDN)
       ============================================================ -->

  <!-- Mapbox GL JS v3.3.0 -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>

  <!-- Fonts: JetBrains Mono for technical data, Inter for UI -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ============================================================
       SECTION: CSS Reset & Base
       Establishes consistent rendering across all browsers
       Could be extracted to: css/reset.css
       ============================================================ */
    *, *::before, *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: var(--font-primary);
      background: var(--bg-void);
      color: var(--text-primary);
      line-height: 1.5;
    }

    button {
      font-family: inherit;
      cursor: pointer;
      border: none;
      background: none;
    }

    input {
      font-family: inherit;
      border: none;
      background: none;
      outline: none;
    }

    /* ============================================================
       SECTION: CSS Variables & Design Tokens
       "Obsidian Lux" Design System
       Could be extracted to: css/variables.css
       ============================================================ */
    :root {
      /* Typography */
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      --font-mono: 'JetBrains Mono', 'SF Mono', 'Fira Code', monospace;

      /* Spacing Scale (4px base) */
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 20px;
      --space-6: 24px;
      --space-8: 32px;
      --space-10: 40px;
      --space-12: 48px;
      --space-16: 64px;

      /* Border Radius */
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-full: 9999px;

      /* Transitions - Smooth, premium feel */
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
      --ease-out-quad: cubic-bezier(0.25, 0.46, 0.45, 0.94);
      --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);

      --transition-fast: 150ms var(--ease-out-quad);
      --transition-base: 250ms var(--ease-out-expo);
      --transition-slow: 400ms var(--ease-out-expo);
      --transition-slower: 600ms var(--ease-out-expo);

      /* Z-Index Scale */
      --z-map: 0;
      --z-controls: 100;
      --z-dropdown: 200;
      --z-popup: 300;
      --z-modal: 400;
      --z-loading: 9999;

      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }

    /* ============================================================
       SECTION: Dark Theme - "Obsidian"
       Deep blue-blacks with electric cyan accents
       ============================================================ */
    :root[data-theme="dark"] {
      /* Base Colors - Deep blue-black, not pure black */
      --bg-void: #05070a;
      --bg-primary: #0a0e14;
      --bg-elevated: #111820;
      --bg-surface: #1a2332;
      --bg-hover: #232f42;

      /* Text Colors - Warm whites for readability */
      --text-primary: #f0f4f8;
      --text-secondary: #8899a6;
      --text-muted: #4a5568;
      --text-disabled: #2d3748;

      /* Accent Colors */
      --accent-primary: #00d4ff;
      --accent-primary-hover: #33ddff;
      --accent-secondary: #ff6b6b;
      --accent-tertiary: #7c3aed;
      --accent-glow: rgba(0, 212, 255, 0.4);
      --accent-glow-strong: rgba(0, 212, 255, 0.6);

      /* Event Type Colors - Distinct, colorblind-friendly palette */
      --color-call-in: #10b981;
      --color-call-out: #3b82f6;
      --color-text-in: #f59e0b;
      --color-text-out: #ec4899;

      /* Event Type Backgrounds */
      --color-call-in-bg: rgba(16, 185, 129, 0.15);
      --color-call-out-bg: rgba(59, 130, 246, 0.15);
      --color-text-in-bg: rgba(245, 158, 11, 0.15);
      --color-text-out-bg: rgba(236, 72, 153, 0.15);

      /* Glassmorphic Properties */
      --glass-bg: rgba(10, 14, 20, 0.85);
      --glass-bg-hover: rgba(17, 24, 32, 0.9);
      --glass-border: rgba(255, 255, 255, 0.06);
      --glass-border-hover: rgba(255, 255, 255, 0.1);
      --glass-highlight: rgba(255, 255, 255, 0.03);
      --glass-shadow: rgba(0, 0, 0, 0.5);
      --glass-blur: 20px;

      /* Mapbox Style */
      --map-style: mapbox://styles/mapbox/dark-v11;

      /* Scrollbar */
      --scrollbar-track: rgba(255, 255, 255, 0.02);
      --scrollbar-thumb: rgba(255, 255, 255, 0.1);
      --scrollbar-thumb-hover: rgba(255, 255, 255, 0.2);
    }

    /* ============================================================
       SECTION: Light Theme - "Porcelain"
       Warm off-whites with deeper accent tones
       ============================================================ */
    :root[data-theme="light"] {
      /* Base Colors - Warm off-whites */
      --bg-void: #f8fafc;
      --bg-primary: #ffffff;
      --bg-elevated: #ffffff;
      --bg-surface: #f1f5f9;
      --bg-hover: #e2e8f0;

      /* Text Colors - Rich blacks */
      --text-primary: #0f172a;
      --text-secondary: #475569;
      --text-muted: #94a3b8;
      --text-disabled: #cbd5e1;

      /* Accent Colors - Deeper variants for contrast */
      --accent-primary: #0891b2;
      --accent-primary-hover: #0e7490;
      --accent-secondary: #e11d48;
      --accent-tertiary: #6d28d9;
      --accent-glow: rgba(8, 145, 178, 0.2);
      --accent-glow-strong: rgba(8, 145, 178, 0.35);

      /* Event Type Colors */
      --color-call-in: #059669;
      --color-call-out: #2563eb;
      --color-text-in: #d97706;
      --color-text-out: #db2777;

      /* Event Type Backgrounds */
      --color-call-in-bg: rgba(5, 150, 105, 0.1);
      --color-call-out-bg: rgba(37, 99, 235, 0.1);
      --color-text-in-bg: rgba(217, 119, 6, 0.1);
      --color-text-out-bg: rgba(219, 39, 119, 0.1);

      /* Glassmorphic Properties - Lighter, crisper */
      --glass-bg: rgba(255, 255, 255, 0.92);
      --glass-bg-hover: rgba(255, 255, 255, 0.96);
      --glass-border: rgba(0, 0, 0, 0.06);
      --glass-border-hover: rgba(0, 0, 0, 0.1);
      --glass-highlight: rgba(255, 255, 255, 0.8);
      --glass-shadow: rgba(0, 0, 0, 0.08);
      --glass-blur: 16px;

      /* Mapbox Style */
      --map-style: mapbox://styles/mapbox/light-v11;

      /* Scrollbar */
      --scrollbar-track: rgba(0, 0, 0, 0.02);
      --scrollbar-thumb: rgba(0, 0, 0, 0.1);
      --scrollbar-thumb-hover: rgba(0, 0, 0, 0.2);
    }

    /* ============================================================
       SECTION: Theme Transition
       Smooth cross-fade when switching themes
       ============================================================ */
    html {
      transition: background-color var(--transition-slow);
    }

    /* ============================================================
       SECTION: Map Container
       Full viewport coverage
       Could be extracted to: css/components/map.css
       ============================================================ */
    #map {
      position: absolute;
      inset: 0;
      z-index: var(--z-map);
    }

    /* Hide default Mapbox attribution - we'll add custom */
    .mapboxgl-ctrl-attrib {
      display: none !important;
    }

    /* Style Mapbox navigation controls */
    .mapboxgl-ctrl-group {
      background: var(--glass-bg) !important;
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border) !important;
      border-radius: var(--radius-md) !important;
      box-shadow: 0 8px 32px var(--glass-shadow) !important;
      overflow: hidden;
    }

    .mapboxgl-ctrl-group button {
      width: 36px !important;
      height: 36px !important;
      background: transparent !important;
      border: none !important;
      color: var(--text-primary) !important;
    }

    .mapboxgl-ctrl-group button:hover {
      background: var(--bg-hover) !important;
    }

    .mapboxgl-ctrl-group button + button {
      border-top: 1px solid var(--glass-border) !important;
    }

    .mapboxgl-ctrl-group button .mapboxgl-ctrl-icon {
      filter: var(--text-primary) == '#f0f4f8' ? invert(1) : none;
    }

    [data-theme="dark"] .mapboxgl-ctrl-group button .mapboxgl-ctrl-icon {
      filter: invert(1) brightness(0.9);
    }

    /* Style Mapbox scale control */
    .mapboxgl-ctrl-scale {
      background: var(--glass-bg) !important;
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border) !important;
      border-radius: var(--radius-sm) !important;
      font-family: var(--font-mono) !important;
      font-size: 10px !important;
      color: var(--text-secondary) !important;
      padding: 2px 6px !important;
      box-shadow: 0 4px 12px var(--glass-shadow) !important;
    }

    /* Style Mapbox popups */
    .mapboxgl-popup {
      z-index: var(--z-popup);
    }

    .mapboxgl-popup-content {
      background: var(--glass-bg) !important;
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border) !important;
      border-radius: var(--radius-lg) !important;
      box-shadow:
        0 12px 40px var(--glass-shadow),
        inset 0 1px 0 var(--glass-highlight) !important;
      padding: 0 !important;
      overflow: hidden;
    }

    .mapboxgl-popup-close-button {
      color: var(--text-muted) !important;
      font-size: 18px !important;
      padding: 4px 10px !important;
      right: 4px !important;
      top: 4px !important;
      transition: color var(--transition-fast);
    }

    .mapboxgl-popup-close-button:hover {
      color: var(--text-primary) !important;
      background: transparent !important;
    }

    .mapboxgl-popup-anchor-top .mapboxgl-popup-tip,
    .mapboxgl-popup-anchor-top-left .mapboxgl-popup-tip,
    .mapboxgl-popup-anchor-top-right .mapboxgl-popup-tip {
      border-bottom-color: var(--glass-bg) !important;
    }

    .mapboxgl-popup-anchor-bottom .mapboxgl-popup-tip,
    .mapboxgl-popup-anchor-bottom-left .mapboxgl-popup-tip,
    .mapboxgl-popup-anchor-bottom-right .mapboxgl-popup-tip {
      border-top-color: var(--glass-bg) !important;
    }

    .mapboxgl-popup-anchor-left .mapboxgl-popup-tip {
      border-right-color: var(--glass-bg) !important;
    }

    .mapboxgl-popup-anchor-right .mapboxgl-popup-tip {
      border-left-color: var(--glass-bg) !important;
    }

    /* ============================================================
       SECTION: Glass Panel Base
       Premium glassmorphic panel styling
       Could be extracted to: css/components/glass-panel.css
       ============================================================ */
    .glass-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      -webkit-backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow:
        0 8px 32px var(--glass-shadow),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 0 0 1px rgba(255, 255, 255, 0.02);
      transition:
        transform var(--transition-base),
        box-shadow var(--transition-base),
        border-color var(--transition-base);
    }

    .glass-panel:hover {
      border-color: var(--glass-border-hover);
      box-shadow:
        0 12px 40px var(--glass-shadow),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 0 0 1px rgba(255, 255, 255, 0.02);
    }

    /* Active/focused state with accent glow */
    .glass-panel--active,
    .glass-panel:focus-within {
      border-color: var(--accent-primary);
      box-shadow:
        0 0 0 1px var(--accent-primary),
        0 0 30px var(--accent-glow),
        0 8px 32px var(--glass-shadow),
        inset 0 1px 0 var(--glass-highlight);
    }

    /* ============================================================
       SECTION: Control Panel Layout
       Floating panels positioned around the viewport
       Could be extracted to: css/layout/controls.css
       ============================================================ */
    .controls-top-left {
      position: absolute;
      top: var(--space-6);
      left: var(--space-6);
      z-index: var(--z-controls);
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      max-height: calc(100vh - var(--space-12) - 200px);
    }

    .controls-top-right {
      position: absolute;
      top: var(--space-6);
      right: var(--space-6);
      z-index: var(--z-controls);
    }

    .controls-bottom {
      position: absolute;
      bottom: var(--space-6);
      left: var(--space-6);
      right: var(--space-6);
      z-index: var(--z-controls);
    }

    /* ============================================================
       SECTION: Theme Toggle Button
       Sun/Moon icon toggle with smooth transitions
       Could be extracted to: css/components/theme-toggle.css
       ============================================================ */
    .theme-toggle {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-primary);
      position: relative;
      overflow: hidden;
    }

    .theme-toggle:hover {
      color: var(--accent-primary);
      transform: translateY(-2px);
    }

    .theme-toggle:active {
      transform: translateY(0);
    }

    .theme-toggle svg {
      width: 22px;
      height: 22px;
      transition:
        transform var(--transition-base),
        opacity var(--transition-base);
      position: absolute;
    }

    .theme-toggle:hover svg {
      transform: rotate(15deg);
    }

    /* Sun icon visible in dark mode (switch to light) */
    .theme-toggle__sun {
      opacity: 1;
      transform: rotate(0deg) scale(1);
    }

    /* Moon icon visible in light mode (switch to dark) */
    .theme-toggle__moon {
      opacity: 0;
      transform: rotate(-90deg) scale(0.5);
    }

    [data-theme="light"] .theme-toggle__sun {
      opacity: 0;
      transform: rotate(90deg) scale(0.5);
    }

    [data-theme="light"] .theme-toggle__moon {
      opacity: 1;
      transform: rotate(0deg) scale(1);
    }

    /* ============================================================
       SECTION: Loading Overlay
       Full-screen loading state with spinner
       Could be extracted to: css/components/loading.css
       ============================================================ */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg-void);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: var(--z-loading);
      transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
    }

    .loading-overlay--hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .loading-spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--glass-border);
      border-top-color: var(--accent-primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    .loading-text {
      margin-top: var(--space-4);
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      letter-spacing: 0.02em;
    }

    .loading-subtext {
      margin-top: var(--space-2);
      font-size: 12px;
      color: var(--text-muted);
      font-family: var(--font-mono);
    }

    /* ============================================================
       SECTION: Keyframe Animations
       Reusable animations for various components
       Could be extracted to: css/animations.css
       ============================================================ */
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeInDown {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @keyframes glow {
      0%, 100% {
        box-shadow: 0 0 20px var(--accent-glow);
      }
      50% {
        box-shadow: 0 0 40px var(--accent-glow-strong);
      }
    }

    /* Entrance animations for control panels */
    .controls-top-left {
      animation: fadeInDown 0.6s var(--ease-out-expo) 0.2s backwards;
    }

    .controls-top-right {
      animation: fadeInDown 0.6s var(--ease-out-expo) 0.3s backwards;
    }

    .controls-bottom {
      animation: fadeInUp 0.6s var(--ease-out-expo) 0.4s backwards;
    }

    /* ============================================================
       SECTION: Custom Scrollbar
       Styled scrollbars for glassmorphic panels
       ============================================================ */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: var(--radius-full);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: var(--radius-full);
      transition: background var(--transition-fast);
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover);
    }

    /* Firefox */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
    }

    /* ============================================================
       SECTION: Utility Classes
       Common utility patterns
       ============================================================ */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .text-mono {
      font-family: var(--font-mono);
    }

    .text-muted {
      color: var(--text-muted);
    }

    .text-accent {
      color: var(--accent-primary);
    }

    /* ============================================================
       SECTION: World Clock Display
       Premium flip-clock style time display
       Could be extracted to: css/components/world-clock.css
       ============================================================ */
    .world-clock {
      padding: var(--space-4) var(--space-5);
      min-width: 200px;
      text-align: center;
    }

    .world-clock__date {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      margin-bottom: var(--space-2);
    }

    .world-clock__time {
      font-family: var(--font-mono);
      font-size: 36px;
      font-weight: 600;
      color: var(--text-primary);
      letter-spacing: -0.02em;
      display: flex;
      align-items: baseline;
      justify-content: center;
      gap: 2px;
    }

    .world-clock__digit {
      display: inline-block;
      min-width: 0.55em;
      text-align: center;
      transition: transform var(--transition-fast);
    }

    .world-clock__digit--flip {
      animation: digitFlip 200ms ease-out;
    }

    @keyframes digitFlip {
      0% {
        transform: translateY(-50%);
        opacity: 0;
      }
      50% {
        transform: translateY(5%);
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .world-clock__colon {
      color: var(--text-muted);
      animation: colonBlink 1s step-end infinite;
    }

    @keyframes colonBlink {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 0.2; }
    }

    .world-clock__seconds {
      font-size: 18px;
      color: var(--text-muted);
      margin-left: var(--space-1);
    }

    .world-clock__seconds .world-clock__colon {
      font-size: 18px;
    }

    .world-clock__timezone {
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--accent-primary);
      margin-top: var(--space-2);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ============================================================
       SECTION: Time Controls & Slider
       Playback controls, speed buttons, and timeline slider
       Could be extracted to: css/components/time-controls.css
       ============================================================ */
    .time-controls {
      padding: var(--space-5);
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    .time-controls__row {
      display: flex;
      align-items: center;
      gap: var(--space-4);
    }

    /* Playback buttons (step back, play/pause, step forward) */
    .time-controls__playback {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      flex-shrink: 0;
    }

    .time-controls__btn {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-md);
      background: var(--bg-surface);
      color: var(--text-primary);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }

    .time-controls__btn:hover {
      background: var(--accent-primary);
      color: var(--bg-primary);
      transform: scale(1.05);
    }

    .time-controls__btn:active {
      transform: scale(0.95);
    }

    .time-controls__btn--play {
      width: 48px;
      height: 48px;
      background: var(--accent-primary);
      color: var(--bg-primary);
      border-radius: var(--radius-lg);
      box-shadow: 0 4px 20px var(--accent-glow);
    }

    .time-controls__btn--play:hover {
      background: var(--accent-primary-hover);
      box-shadow: 0 6px 30px var(--accent-glow-strong);
    }

    .time-controls__btn--play.is-playing {
      animation: playingPulse 2s ease-in-out infinite;
    }

    @keyframes playingPulse {
      0%, 100% { box-shadow: 0 4px 20px var(--accent-glow); }
      50% { box-shadow: 0 4px 30px var(--accent-glow-strong); }
    }

    .time-controls__btn svg {
      width: 18px;
      height: 18px;
    }

    .time-controls__btn--play svg {
      width: 22px;
      height: 22px;
    }

    /* Speed control buttons */
    .time-controls__speed {
      display: flex;
      gap: var(--space-1);
      flex-shrink: 0;
    }

    .time-controls__speed-btn {
      padding: var(--space-1) var(--space-2);
      font-size: 11px;
      font-family: var(--font-mono);
      font-weight: 600;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      background: transparent;
      color: var(--text-muted);
      transition: all var(--transition-fast);
    }

    .time-controls__speed-btn:hover {
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .time-controls__speed-btn--active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-primary);
    }

    /* Time slider */
    .time-slider {
      flex: 1;
      position: relative;
      height: 48px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-width: 200px;
    }

    .time-slider__track {
      position: relative;
      height: 8px;
      background: var(--bg-surface);
      border-radius: var(--radius-full);
      cursor: pointer;
      overflow: visible;
    }

    .time-slider__density {
      position: absolute;
      inset: 0;
      border-radius: var(--radius-full);
      opacity: 0.5;
    }

    .time-slider__range {
      position: absolute;
      top: 0;
      bottom: 0;
      background: rgba(0, 212, 255, 0.2);
      border-radius: var(--radius-full);
    }

    .time-slider__progress {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
      border-radius: var(--radius-full);
      transition: width 50ms linear;
    }

    .time-slider__handle {
      position: absolute;
      top: 50%;
      width: 18px;
      height: 18px;
      background: var(--text-primary);
      border: 3px solid var(--accent-primary);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      cursor: grab;
      transition:
        transform var(--transition-fast),
        box-shadow var(--transition-fast);
      z-index: 2;
    }

    .time-slider__handle:hover {
      transform: translate(-50%, -50%) scale(1.2);
      box-shadow: 0 0 20px var(--accent-glow);
    }

    .time-slider__handle:active,
    .time-slider__handle.is-dragging {
      cursor: grabbing;
      transform: translate(-50%, -50%) scale(1.3);
      box-shadow: 0 0 30px var(--accent-glow-strong);
    }

    .time-slider__labels {
      display: flex;
      justify-content: space-between;
      margin-top: var(--space-2);
    }

    .time-slider__label {
      font-size: 10px;
      font-family: var(--font-mono);
      color: var(--text-muted);
    }

    /* Current time display in slider */
    .time-slider__current {
      position: absolute;
      top: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      font-family: var(--font-mono);
      font-weight: 500;
      color: var(--accent-primary);
      background: var(--bg-surface);
      padding: 2px 8px;
      border-radius: var(--radius-sm);
      white-space: nowrap;
      opacity: 0;
      transition: opacity var(--transition-fast);
    }

    .time-slider:hover .time-slider__current,
    .time-slider__handle.is-dragging ~ .time-slider__current {
      opacity: 1;
    }

    /* ============================================================
       SECTION: Contact Filter Component
       Multi-select contact list with search and presets
       Could be extracted to: css/components/contact-filter.css
       ============================================================ */
    .contact-filter {
      width: 280px;
    }

    .contact-filter__header {
      padding: var(--space-4);
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--glass-border);
    }

    .contact-filter__title {
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .contact-filter__count {
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--accent-primary);
      background: rgba(0, 212, 255, 0.1);
      padding: 2px 8px;
      border-radius: var(--radius-full);
    }

    .contact-filter__search {
      padding: var(--space-3) var(--space-4);
      border-bottom: 1px solid var(--glass-border);
    }

    .contact-filter__search-input {
      width: 100%;
      background: var(--bg-surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: var(--space-2) var(--space-3);
      font-size: 13px;
      color: var(--text-primary);
      outline: none;
      transition: border-color var(--transition-fast);
    }

    .contact-filter__search-input::placeholder {
      color: var(--text-muted);
    }

    .contact-filter__search-input:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px var(--accent-glow);
    }

    .contact-filter__presets {
      padding: var(--space-3) var(--space-4);
      display: flex;
      gap: var(--space-2);
      border-bottom: 1px solid var(--glass-border);
    }

    .contact-filter__preset {
      flex: 1;
      padding: var(--space-2) var(--space-3);
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.03em;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .contact-filter__preset:hover {
      background: var(--bg-surface);
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .contact-filter__preset--active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-primary);
    }

    .contact-filter__preset--active:hover {
      background: var(--accent-primary-hover);
      border-color: var(--accent-primary-hover);
      color: var(--bg-primary);
    }

    .contact-filter__list {
      max-height: 240px;
      overflow-y: auto;
      padding: var(--space-2);
    }

    .contact-filter__item {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-2) var(--space-3);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background var(--transition-fast);
    }

    .contact-filter__item:hover {
      background: var(--bg-surface);
    }

    .contact-filter__checkbox {
      width: 16px;
      height: 16px;
      border: 2px solid var(--text-muted);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
      flex-shrink: 0;
    }

    .contact-filter__item--selected .contact-filter__checkbox {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
    }

    .contact-filter__checkbox-icon {
      width: 10px;
      height: 10px;
      stroke: var(--bg-primary);
      stroke-width: 3;
      opacity: 0;
      transform: scale(0.5);
      transition: all var(--transition-fast);
    }

    .contact-filter__item--selected .contact-filter__checkbox-icon {
      opacity: 1;
      transform: scale(1);
    }

    .contact-filter__contact-info {
      flex: 1;
      min-width: 0;
    }

    .contact-filter__contact-id {
      font-size: 13px;
      font-family: var(--font-mono);
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .contact-filter__contact-stats {
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      gap: var(--space-2);
      margin-top: 2px;
    }

    .contact-filter__stat {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .contact-filter__stat-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
    }

    .contact-filter__stat-dot--calls {
      background: var(--color-call-in);
    }

    .contact-filter__stat-dot--texts {
      background: var(--color-text-in);
    }

    .contact-filter__empty {
      padding: var(--space-6) var(--space-4);
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* ============================================================
       SECTION: Date/Time Picker Component
       Calendar-based date range selection with presets
       Could be extracted to: css/components/datetime-picker.css
       ============================================================ */
    .datetime-picker {
      position: relative;
    }

    .datetime-picker__trigger {
      display: flex;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-3) var(--space-4);
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .datetime-picker__trigger:hover {
      border-color: var(--accent-primary);
      box-shadow: 0 0 16px var(--accent-glow);
    }

    .datetime-picker__trigger-icon {
      width: 18px;
      height: 18px;
      color: var(--accent-primary);
      flex-shrink: 0;
    }

    .datetime-picker__trigger-text {
      font-size: 13px;
      font-family: var(--font-mono);
      color: var(--text-primary);
      white-space: nowrap;
    }

    .datetime-picker__dropdown {
      position: absolute;
      bottom: calc(100% + var(--space-2));
      left: 0;
      width: 320px;
      z-index: var(--z-dropdown);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: all var(--transition-base);
    }

    .datetime-picker--open .datetime-picker__dropdown {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .datetime-picker__presets {
      padding: var(--space-4);
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--space-2);
      border-bottom: 1px solid var(--glass-border);
    }

    .datetime-picker__preset {
      padding: var(--space-2) var(--space-3);
      font-size: 11px;
      font-weight: 500;
      text-align: center;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .datetime-picker__preset:hover {
      background: var(--bg-surface);
      color: var(--text-primary);
      border-color: var(--text-muted);
    }

    .datetime-picker__preset--active {
      background: var(--accent-primary);
      border-color: var(--accent-primary);
      color: var(--bg-primary);
    }

    .datetime-picker__calendar {
      padding: var(--space-4);
    }

    .datetime-picker__calendar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-4);
    }

    .datetime-picker__nav-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: var(--bg-surface);
      border-radius: var(--radius-sm);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }

    .datetime-picker__nav-btn:hover {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    .datetime-picker__month-year {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .datetime-picker__weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
      margin-bottom: var(--space-2);
    }

    .datetime-picker__weekday {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      text-align: center;
      color: var(--text-muted);
      padding: var(--space-1);
    }

    .datetime-picker__days {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
    }

    .datetime-picker__day {
      position: relative;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-fast);
      color: var(--text-primary);
    }

    .datetime-picker__day:hover {
      background: var(--bg-surface);
    }

    .datetime-picker__day--other-month {
      color: var(--text-muted);
      opacity: 0.5;
    }

    .datetime-picker__day--selected {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }

    .datetime-picker__day--in-range {
      background: rgba(0, 212, 255, 0.2);
    }

    .datetime-picker__day--today {
      border: 1px solid var(--accent-primary);
      font-weight: 600;
    }

    .datetime-picker__day--has-data::after {
      content: '';
      position: absolute;
      bottom: 2px;
      width: 4px;
      height: 4px;
      background: var(--accent-secondary);
      border-radius: 50%;
    }

    .datetime-picker__time {
      padding: var(--space-4);
      border-top: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      gap: var(--space-4);
    }

    .datetime-picker__time-label {
      font-size: 12px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .datetime-picker__time-inputs {
      display: flex;
      align-items: center;
      gap: var(--space-2);
      margin-left: auto;
    }

    .datetime-picker__time-input {
      width: 52px;
      padding: var(--space-2);
      font-size: 14px;
      font-family: var(--font-mono);
      text-align: center;
      background: var(--bg-surface);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      color: var(--text-primary);
      outline: none;
      transition: border-color var(--transition-fast);
    }

    .datetime-picker__time-input:focus {
      border-color: var(--accent-primary);
    }

    .datetime-picker__time-separator {
      font-size: 14px;
      font-family: var(--font-mono);
      color: var(--text-muted);
    }

    /* ============================================================
       SECTION: Event Popup Component
       Rich popup for individual CDR events
       Could be extracted to: css/components/event-popup.css
       ============================================================ */
    .event-popup {
      min-width: 220px;
      max-width: 280px;
    }

    .event-popup__header {
      padding: var(--space-3) var(--space-4);
      display: flex;
      align-items: center;
      gap: var(--space-3);
      border-bottom: 1px solid var(--glass-border);
    }

    .event-popup__icon {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-md);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .event-popup__icon--call-in {
      background: rgba(16, 185, 129, 0.2);
      color: var(--color-call-in);
    }

    .event-popup__icon--call-out {
      background: rgba(59, 130, 246, 0.2);
      color: var(--color-call-out);
    }

    .event-popup__icon--text-in {
      background: rgba(245, 158, 11, 0.2);
      color: var(--color-text-in);
    }

    .event-popup__icon--text-out {
      background: rgba(236, 72, 153, 0.2);
      color: var(--color-text-out);
    }

    .event-popup__type {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .event-popup__body {
      padding: var(--space-3) var(--space-4);
    }

    .event-popup__row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: var(--space-2) 0;
    }

    .event-popup__row:not(:last-child) {
      border-bottom: 1px solid var(--glass-border);
    }

    .event-popup__label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .event-popup__value {
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--text-primary);
    }

    /* ============================================================
       SECTION: Cluster Popup Component
       Summary popup for clustered event groups
       Could be extracted to: css/components/cluster-popup.css
       ============================================================ */
    .cluster-popup {
      min-width: 240px;
    }

    .cluster-popup__header {
      padding: var(--space-4);
      text-align: center;
      border-bottom: 1px solid var(--glass-border);
    }

    .cluster-popup__count {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-primary);
      font-family: var(--font-mono);
    }

    .cluster-popup__label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      margin-top: var(--space-1);
    }

    .cluster-popup__breakdown {
      padding: var(--space-4);
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-3);
    }

    .cluster-popup__stat {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .cluster-popup__stat-color {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .cluster-popup__stat-value {
      font-size: 13px;
      font-family: var(--font-mono);
      color: var(--text-primary);
    }

    .cluster-popup__stat-type {
      font-size: 10px;
      color: var(--text-muted);
    }

    .cluster-popup__action {
      display: block;
      width: 100%;
      padding: var(--space-3);
      background: var(--accent-primary);
      border: none;
      border-radius: 0 0 var(--radius-lg) var(--radius-lg);
      color: var(--bg-primary);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background var(--transition-fast);
    }

    .cluster-popup__action:hover {
      background: var(--accent-secondary);
    }

    /* ============================================================
       SECTION: Popup Animations
       Smooth entrance animations for map popups
       NOTE: Cannot use transform animations as they conflict with
       Mapbox's internal positioning transforms (which use translate)
       ============================================================ */
    .mapboxgl-popup {
      animation: popupFadeIn 0.2s ease-out forwards;
    }

    @keyframes popupFadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    /* ============================================================
       SECTION: Event Legend
       Color-coded legend for event types
       Could be extracted to: css/components/legend.css
       ============================================================ */
    .event-legend {
      display: flex;
      flex-direction: column;
      gap: var(--space-2);
      padding: var(--space-3) var(--space-4);
      margin-top: var(--space-3);
      border-top: 1px solid var(--glass-border);
    }

    .event-legend__title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      margin-bottom: var(--space-1);
    }

    .event-legend__grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-2);
    }

    .event-legend__item {
      display: flex;
      align-items: center;
      gap: var(--space-2);
    }

    .event-legend__color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
      box-shadow: 0 0 6px currentColor;
    }

    .event-legend__color--call-in { background: var(--color-call-in); color: var(--color-call-in); }
    .event-legend__color--call-out { background: var(--color-call-out); color: var(--color-call-out); }
    .event-legend__color--text-in { background: var(--color-text-in); color: var(--color-text-in); }
    .event-legend__color--text-out { background: var(--color-text-out); color: var(--color-text-out); }

    .event-legend__label {
      font-size: 11px;
      color: var(--text-secondary);
    }

    /* ============================================================
       SECTION: Focus States & Accessibility
       Enhanced keyboard navigation support
       ============================================================ */
    *:focus-visible {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
    }

    button:focus-visible,
    input:focus-visible,
    .glass-panel:focus-visible {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px var(--accent-glow);
    }

    /* Skip focus outline for mouse users */
    button:focus:not(:focus-visible),
    input:focus:not(:focus-visible) {
      outline: none;
    }

    /* ============================================================
       SECTION: Contact Filter Item Animation
       Staggered entrance for contact list items
       ============================================================ */
    .contact-filter__item {
      animation: contactItemEnter 0.3s var(--ease-out-expo) backwards;
    }

    @keyframes contactItemEnter {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* ============================================================
       SECTION: Stats Summary Badge
       Event count badge for quick reference
       ============================================================ */
    .stats-badge {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: var(--space-2) var(--space-3);
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur));
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-full);
      font-size: 12px;
      font-family: var(--font-mono);
      color: var(--text-secondary);
    }

    .stats-badge__count {
      font-weight: 600;
      color: var(--accent-primary);
    }

    .stats-badge__icon {
      width: 14px;
      height: 14px;
      color: var(--text-muted);
    }

    /* ============================================================
       SECTION: Responsive Breakpoints
       Mobile-first responsive adjustments
       Could be extracted to: css/responsive.css
       ============================================================ */
    /* Large tablets and small desktops */
    @media (max-width: 1024px) {
      :root {
        --space-6: 20px;
      }

      .contact-filter {
        width: 260px;
      }

      .world-clock__time {
        font-size: 32px;
      }

      .world-clock__digit {
        width: 26px;
      }
    }

    /* Tablets */
    @media (max-width: 768px) {
      :root {
        --space-6: 16px;
      }

      .controls-top-left {
        top: var(--space-3);
        left: var(--space-3);
        max-height: calc(100vh - 180px);
      }

      .controls-top-right {
        top: var(--space-3);
        right: var(--space-3);
      }

      .controls-bottom {
        left: var(--space-3);
        right: var(--space-3);
        bottom: var(--space-3);
      }

      .contact-filter {
        width: 220px;
      }

      .contact-filter__list {
        max-height: 180px;
      }

      .world-clock__time {
        font-size: 26px;
      }

      .world-clock__digit {
        width: 22px;
      }

      .time-controls__row {
        flex-wrap: wrap;
        gap: var(--space-2);
      }

      .datetime-picker__dropdown {
        left: auto;
        right: 0;
        width: 300px;
      }

      .datetime-picker__presets {
        gap: var(--space-1);
      }

      .datetime-picker__preset {
        padding: var(--space-2) var(--space-2);
        font-size: 11px;
      }

      .event-legend__grid {
        gap: var(--space-1);
      }
    }

    /* Small tablets and large phones */
    @media (max-width: 600px) {
      .controls-top-left {
        width: 200px;
      }

      .contact-filter__header {
        padding: var(--space-2) var(--space-3);
      }

      .contact-filter__search {
        padding: var(--space-2) var(--space-3);
      }

      .world-clock {
        padding: var(--space-3);
      }

      .time-controls {
        padding: var(--space-3);
      }

      .time-controls__playback {
        gap: var(--space-2);
      }

      .time-controls__btn {
        width: 36px;
        height: 36px;
      }

      .time-controls__btn--play {
        width: 44px;
        height: 44px;
      }
    }

    /* Phones */
    @media (max-width: 480px) {
      .controls-top-left {
        position: fixed;
        top: var(--space-2);
        left: var(--space-2);
        width: 180px;
        max-height: 50vh;
      }

      .controls-top-right {
        position: fixed;
        top: var(--space-2);
        right: var(--space-2);
      }

      .controls-bottom {
        left: var(--space-2);
        right: var(--space-2);
        bottom: var(--space-2);
      }

      .world-clock__time {
        font-size: 22px;
      }

      .world-clock__digit {
        width: 18px;
      }

      .time-slider__track {
        height: 6px;
      }

      .time-slider__handle {
        width: 14px;
        height: 14px;
      }

      .datetime-picker__dropdown {
        width: calc(100vw - 32px);
        max-width: 300px;
      }

      .datetime-picker__calendar-header {
        padding: var(--space-2) var(--space-3);
      }

      .datetime-picker__day {
        font-size: 12px;
      }

      .event-legend__grid {
        grid-template-columns: 1fr;
      }
    }

    /* Very small phones */
    @media (max-width: 360px) {
      .contact-filter {
        width: 160px;
      }

      .contact-filter__preset {
        padding: var(--space-1) var(--space-2);
        font-size: 10px;
      }

      .time-controls__speed-btns {
        gap: var(--space-1);
      }

      .time-controls__speed-btn {
        padding: var(--space-1) var(--space-2);
        font-size: 10px;
      }
    }

    /* Print styles */
    @media print {
      .controls-top-left,
      .controls-top-right,
      .controls-bottom,
      .loading-overlay {
        display: none !important;
      }

      #map {
        position: relative !important;
        height: 100vh !important;
      }
    }
  </style>
</head>
<body>
  <!-- ============================================================
       Loading Overlay
       Shown during initialization, fades out when ready
       ============================================================ -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Initializing Visualization</div>
    <div class="loading-subtext">Loading map and data...</div>
  </div>

  <!-- ============================================================
       Map Container
       Full viewport Mapbox GL JS map
       ============================================================ -->
  <div id="map"></div>

  <!-- ============================================================
       Top Left Controls
       Theme toggle and contact filter
       ============================================================ -->
  <div class="controls-top-left">
    <!-- Theme Toggle Button -->
    <button class="theme-toggle glass-panel" id="themeToggle" aria-label="Toggle dark/light theme">
      <!-- Sun icon (visible in dark mode) -->
      <svg class="theme-toggle__sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="12" cy="12" r="5"/>
        <line x1="12" y1="1" x2="12" y2="3"/>
        <line x1="12" y1="21" x2="12" y2="23"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
        <line x1="1" y1="12" x2="3" y2="12"/>
        <line x1="21" y1="12" x2="23" y2="12"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
      </svg>
      <!-- Moon icon (visible in light mode) -->
      <svg class="theme-toggle__moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
      </svg>
    </button>

    <!-- Contact Filter Panel - Multi-select contact list -->
    <div class="contact-filter glass-panel" id="contactFilter">
      <div class="contact-filter__header">
        <span class="contact-filter__title">Contacts</span>
        <span class="contact-filter__count" id="contactCount">0/0</span>
      </div>
      <div class="contact-filter__search">
        <input
          type="text"
          class="contact-filter__search-input"
          placeholder="Search contacts..."
          id="contactSearch"
        >
      </div>
      <div class="contact-filter__presets">
        <button class="contact-filter__preset contact-filter__preset--active" data-preset="all">All</button>
        <button class="contact-filter__preset" data-preset="top10">Top 10</button>
        <button class="contact-filter__preset" data-preset="none">None</button>
      </div>
      <div class="contact-filter__list" id="contactList">
        <!-- Contact items populated by JavaScript -->
        <div class="contact-filter__empty" id="contactListEmpty">
          No contacts loaded
        </div>
      </div>

      <!-- Event Type Legend -->
      <div class="event-legend">
        <div class="event-legend__title">Event Types</div>
        <div class="event-legend__grid">
          <div class="event-legend__item">
            <div class="event-legend__color event-legend__color--call-in"></div>
            <span class="event-legend__label">Calls In</span>
          </div>
          <div class="event-legend__item">
            <div class="event-legend__color event-legend__color--call-out"></div>
            <span class="event-legend__label">Calls Out</span>
          </div>
          <div class="event-legend__item">
            <div class="event-legend__color event-legend__color--text-in"></div>
            <span class="event-legend__label">Texts In</span>
          </div>
          <div class="event-legend__item">
            <div class="event-legend__color event-legend__color--text-out"></div>
            <span class="event-legend__label">Texts Out</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ============================================================
       Top Right Controls
       World clock display
       ============================================================ -->
  <div class="controls-top-right">
    <!-- World Clock - Premium flip-clock style display -->
    <div class="world-clock glass-panel" id="worldClock">
      <div class="world-clock__date" id="clockDate">Mon, Jan 15 2025</div>
      <div class="world-clock__time">
        <span class="world-clock__digit" id="hour1">0</span>
        <span class="world-clock__digit" id="hour2">0</span>
        <span class="world-clock__colon">:</span>
        <span class="world-clock__digit" id="min1">0</span>
        <span class="world-clock__digit" id="min2">0</span>
        <span class="world-clock__seconds">
          <span class="world-clock__colon">:</span>
          <span class="world-clock__digit" id="sec1">0</span>
          <span class="world-clock__digit" id="sec2">0</span>
        </span>
      </div>
      <div class="world-clock__timezone" id="clockTimezone">UTC</div>
      <!-- Event Stats Badge -->
      <div class="stats-badge" id="eventStats" style="margin-top: var(--space-3);">
        <svg class="stats-badge__icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 12h-4l-3 9L9 3l-3 9H2"/>
        </svg>
        <span class="stats-badge__count" id="eventCount">0</span>
        <span>events</span>
      </div>
    </div>
  </div>

  <!-- ============================================================
       Bottom Controls
       Time slider, playback controls, date picker
       ============================================================ -->
  <div class="controls-bottom">
    <div class="time-controls glass-panel" id="timeControls">
      <div class="time-controls__row">
        <!-- Playback Controls -->
        <div class="time-controls__playback">
          <button class="time-controls__btn" id="stepBack" aria-label="Step backward">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z"/>
            </svg>
          </button>
          <button class="time-controls__btn time-controls__btn--play" id="playPause" aria-label="Play/Pause">
            <svg class="play-icon" viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7L8 5z"/>
            </svg>
            <svg class="pause-icon" viewBox="0 0 24 24" fill="currentColor" style="display: none;">
              <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
            </svg>
          </button>
          <button class="time-controls__btn" id="stepForward" aria-label="Step forward">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 18l8.5-6L6 6v12zm2 0V6l6.5 6L8 18zm10-12h2v12h-2V6z"/>
            </svg>
          </button>
        </div>

        <!-- Speed Controls -->
        <div class="time-controls__speed">
          <button class="time-controls__speed-btn" data-speed="0.5">0.5x</button>
          <button class="time-controls__speed-btn time-controls__speed-btn--active" data-speed="1">1x</button>
          <button class="time-controls__speed-btn" data-speed="2">2x</button>
          <button class="time-controls__speed-btn" data-speed="5">5x</button>
          <button class="time-controls__speed-btn" data-speed="10">10x</button>
        </div>

        <!-- Time Slider -->
        <div class="time-slider" id="timeSlider">
          <div class="time-slider__current" id="sliderCurrentTime">--:--</div>
          <div class="time-slider__track">
            <div class="time-slider__density" id="sliderDensity"></div>
            <div class="time-slider__range" id="sliderRange"></div>
            <div class="time-slider__progress" id="sliderProgress"></div>
            <div class="time-slider__handle" id="sliderHandle" style="left: 0%"></div>
          </div>
          <div class="time-slider__labels">
            <span class="time-slider__label" id="sliderLabelStart">--</span>
            <span class="time-slider__label" id="sliderLabelEnd">--</span>
          </div>
        </div>

        <!-- Date/Time Picker -->
        <div class="datetime-picker" id="dateTimePicker">
          <div class="datetime-picker__trigger" id="dateTimePickerTrigger">
            <svg class="datetime-picker__trigger-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
              <line x1="16" y1="2" x2="16" y2="6"/>
              <line x1="8" y1="2" x2="8" y2="6"/>
              <line x1="3" y1="10" x2="21" y2="10"/>
            </svg>
            <span class="datetime-picker__trigger-text" id="dateTimePickerText">Select Range</span>
          </div>
          <div class="datetime-picker__dropdown glass-panel" id="dateTimePickerDropdown">
            <div class="datetime-picker__presets">
              <button class="datetime-picker__preset" data-preset="today">Today</button>
              <button class="datetime-picker__preset" data-preset="yesterday">Yesterday</button>
              <button class="datetime-picker__preset" data-preset="7days">Last 7 Days</button>
              <button class="datetime-picker__preset" data-preset="30days">Last 30 Days</button>
              <button class="datetime-picker__preset" data-preset="thisMonth">This Month</button>
              <button class="datetime-picker__preset datetime-picker__preset--active" data-preset="all">All Data</button>
            </div>
            <div class="datetime-picker__calendar">
              <div class="datetime-picker__calendar-header">
                <button class="datetime-picker__nav-btn" id="calendarPrev" aria-label="Previous month">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                  </svg>
                </button>
                <span class="datetime-picker__month-year" id="calendarMonthYear">January 2025</span>
                <button class="datetime-picker__nav-btn" id="calendarNext" aria-label="Next month">
                  <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                  </svg>
                </button>
              </div>
              <div class="datetime-picker__weekdays">
                <span class="datetime-picker__weekday">Su</span>
                <span class="datetime-picker__weekday">Mo</span>
                <span class="datetime-picker__weekday">Tu</span>
                <span class="datetime-picker__weekday">We</span>
                <span class="datetime-picker__weekday">Th</span>
                <span class="datetime-picker__weekday">Fr</span>
                <span class="datetime-picker__weekday">Sa</span>
              </div>
              <div class="datetime-picker__days" id="calendarDays">
                <!-- Calendar days populated by JavaScript -->
              </div>
            </div>
            <div class="datetime-picker__time">
              <span class="datetime-picker__time-label">Time Range</span>
              <div class="datetime-picker__time-inputs">
                <input type="text" class="datetime-picker__time-input" id="timeStart" value="00:00" maxlength="5" aria-label="Start time">
                <span class="datetime-picker__time-separator">-</span>
                <input type="text" class="datetime-picker__time-input" id="timeEnd" value="23:59" maxlength="5" aria-label="End time">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ============================================================
    // MODULE: Configuration & Constants
    // Centralized configuration for the visualization
    // Could be extracted to: js/config.js
    // ============================================================
    const CONFIG = {
      // Mapbox configuration
      MAPBOX_TOKEN: '{{MAPBOX_TOKEN}}',
      MAPBOX_STYLE_DARK: 'mapbox://styles/mapbox/dark-v11',
      MAPBOX_STYLE_LIGHT: 'mapbox://styles/mapbox/light-v11',

      // Map defaults
      DEFAULT_CENTER: [0, 20],
      DEFAULT_ZOOM: 2,

      // Clustering configuration
      CLUSTER_MAX_ZOOM: 14,
      CLUSTER_RADIUS: 50,

      // Animation configuration
      ANIMATION_TICK_MS: 100,
      TIME_SCALE_FACTOR: 3600000, // 1 real second = 1 hour of data at 1x speed

      // UI configuration
      DEBOUNCE_MS: 150,

      // Popup configuration
      POPUP_MAX_WIDTH: '300px',
    };

    // ============================================================
    // MODULE: EventBus
    // Lightweight publish/subscribe system for decoupled communication
    // Could be extracted to: js/core/EventBus.js
    // ============================================================
    const EventBus = {
      _events: new Map(),
      _onceEvents: new Set(),

      /**
       * Subscribe to an event
       * @param {string} event - Event name
       * @param {Function} callback - Handler function
       * @returns {Function} Unsubscribe function
       */
      on(event, callback) {
        if (!this._events.has(event)) {
          this._events.set(event, new Set());
        }
        this._events.get(event).add(callback);

        // Return unsubscribe function
        return () => this.off(event, callback);
      },

      /**
       * Subscribe to an event once
       * @param {string} event - Event name
       * @param {Function} callback - Handler function
       */
      once(event, callback) {
        const wrapper = (data) => {
          callback(data);
          this.off(event, wrapper);
        };
        this._onceEvents.add(wrapper);
        this.on(event, wrapper);
      },

      /**
       * Unsubscribe from an event
       * @param {string} event - Event name
       * @param {Function} callback - Handler function
       */
      off(event, callback) {
        const handlers = this._events.get(event);
        if (handlers) {
          handlers.delete(callback);
        }
      },

      /**
       * Emit an event with optional data
       * @param {string} event - Event name
       * @param {*} data - Event data
       */
      emit(event, data) {
        const handlers = this._events.get(event);
        if (handlers) {
          handlers.forEach(callback => {
            try {
              callback(data);
            } catch (error) {
              console.error(`[EventBus] Error in handler for "${event}":`, error);
            }
          });
        }
      },

      /**
       * Clear all event subscriptions
       */
      clear() {
        this._events.clear();
        this._onceEvents.clear();
      }
    };

    // ============================================================
    // MODULE: StateManager
    // Single source of truth for application state
    // Could be extracted to: js/core/StateManager.js
    // ============================================================
    const State = {
      _state: {
        // Theme state
        theme: 'dark',

        // Time state
        time: {
          current: null,
          start: null,
          end: null,
          isPlaying: false,
          speed: 1
        },

        // Contact filter state
        contacts: {
          all: [],
          selected: [],
          mode: 'all' // 'all', 'selected', 'top10', 'none'
        },

        // Data state
        data: {
          features: [],
          loaded: false,
          loading: false
        },

        // UI state
        ui: {
          contactFilterOpen: false,
          datePickerOpen: false
        }
      },

      _listeners: new Set(),

      /**
       * Get a value from state by dot-notation path
       * @param {string} path - Dot-notation path (e.g., 'time.current')
       * @returns {*} Value at path
       */
      get(path) {
        return path.split('.').reduce((obj, key) => obj?.[key], this._state);
      },

      /**
       * Set a value in state by dot-notation path
       * @param {string} path - Dot-notation path
       * @param {*} value - New value
       */
      set(path, value) {
        const keys = path.split('.');
        const lastKey = keys.pop();
        const target = keys.reduce((obj, key) => {
          if (obj[key] === undefined) obj[key] = {};
          return obj[key];
        }, this._state);

        const oldValue = target[lastKey];
        target[lastKey] = value;

        // Notify listeners
        this._listeners.forEach(callback => {
          try {
            callback(path, value, oldValue);
          } catch (error) {
            console.error(`[State] Error in listener:`, error);
          }
        });

        // Emit state change event
        EventBus.emit('state:change', { path, value, oldValue });
      },

      /**
       * Subscribe to state changes
       * @param {Function} callback - Handler function (path, newValue, oldValue)
       * @returns {Function} Unsubscribe function
       */
      subscribe(callback) {
        this._listeners.add(callback);
        return () => this._listeners.delete(callback);
      },

      /**
       * Update multiple state values at once
       * @param {Object} updates - Object with path: value pairs
       */
      batch(updates) {
        Object.entries(updates).forEach(([path, value]) => {
          this.set(path, value);
        });
      },

      /**
       * Get a snapshot of the entire state
       * @returns {Object} State snapshot
       */
      snapshot() {
        return JSON.parse(JSON.stringify(this._state));
      }
    };

    // ============================================================
    // MODULE: ThemeController
    // Manages dark/light theme switching
    // Could be extracted to: js/controllers/ThemeController.js
    // ============================================================
    const ThemeController = {
      _storageKey: 'bandicoot-cdr-theme',

      /**
       * Initialize theme controller
       */
      init() {
        // Check for saved preference
        const saved = localStorage.getItem(this._storageKey);

        // Check system preference
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        // Determine initial theme
        const initialTheme = saved || (prefersDark ? 'dark' : 'light');
        this.setTheme(initialTheme, false);

        // Listen for theme toggle clicks
        const toggle = document.getElementById('themeToggle');
        if (toggle) {
          toggle.addEventListener('click', () => this.toggle());
        }

        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
          if (!localStorage.getItem(this._storageKey)) {
            this.setTheme(e.matches ? 'dark' : 'light');
          }
        });

        console.log('[ThemeController] Initialized with theme:', initialTheme);
      },

      /**
       * Set the current theme
       * @param {string} theme - 'dark' or 'light'
       * @param {boolean} save - Whether to save preference
       */
      setTheme(theme, save = true) {
        document.documentElement.setAttribute('data-theme', theme);
        State.set('theme', theme);

        if (save) {
          localStorage.setItem(this._storageKey, theme);
        }

        EventBus.emit('theme:change', { theme });
      },

      /**
       * Toggle between dark and light themes
       */
      toggle() {
        const current = State.get('theme');
        this.setTheme(current === 'dark' ? 'light' : 'dark');
      },

      /**
       * Get the current theme
       * @returns {string} Current theme
       */
      current() {
        return State.get('theme');
      }
    };

    // ============================================================
    // MODULE: MapController
    // Manages Mapbox GL JS map instance, styles, and interactions
    // Could be extracted to: js/controllers/MapController.js
    // ============================================================
    const MapController = {
      map: null,
      popup: null,
      _activePopupKey: null,  // Tracks which feature's popup is open for toggle behavior
      _isStyleLoading: false,
      _pendingOperations: [],
      _allFeatures: null,  // Stores unfiltered features for source-level filtering

      /**
       * Initialize the map
       * @returns {Promise} Resolves when map is loaded
       */
      async init() {
        console.log('[MapController] Initializing...');

        // Validate Mapbox token
        const token = CONFIG.MAPBOX_TOKEN;
        if (!token || token === '{{MAPBOX_TOKEN}}' || !token.startsWith('pk.')) {
          console.warn('[MapController] No valid Mapbox token provided. Using demo mode.');
          // In demo mode, we'll show a message instead of the map
          this._showDemoMode();
          return;
        }

        // Set access token
        mapboxgl.accessToken = token;

        // Determine initial style based on theme
        const theme = State.get('theme');
        const style = theme === 'dark' ? CONFIG.MAPBOX_STYLE_DARK : CONFIG.MAPBOX_STYLE_LIGHT;

        // Create map instance
        this.map = new mapboxgl.Map({
          container: 'map',
          style: style,
          center: CONFIG.DEFAULT_CENTER,
          zoom: CONFIG.DEFAULT_ZOOM,
          attributionControl: false,
          pitchWithRotate: false,
          dragRotate: false,
          touchZoomRotate: true,
          maxZoom: 18,
          minZoom: 1,
          fadeDuration: 300
        });

        // Add navigation controls (zoom only, no compass)
        this.map.addControl(
          new mapboxgl.NavigationControl({
            showCompass: false,
            visualizePitch: false
          }),
          'bottom-right'
        );

        // Add scale control
        this.map.addControl(
          new mapboxgl.ScaleControl({
            maxWidth: 100,
            unit: 'metric'
          }),
          'bottom-left'
        );

        // Wait for map to load
        await new Promise((resolve, reject) => {
          this.map.on('load', resolve);
          this.map.on('error', reject);
        });

        // Listen for theme changes
        EventBus.on('theme:change', ({ theme }) => this._handleThemeChange(theme));

        // Listen for filter updates
        EventBus.on('filter:update', () => this.updateFilters());

        // Emit map ready event
        EventBus.emit('map:ready', { map: this.map });

        console.log('[MapController] Map loaded successfully');

        // Check if data was already loaded before map was ready (race condition fix)
        // This handles the case where user enters token after data was processed
        if (window.BANDICOOT_DATA && window.BANDICOOT_DATA.features && window.BANDICOOT_DATA.features.length > 0) {
          console.log('[MapController] Found existing data, loading', window.BANDICOOT_DATA.features.length, 'features');
          this.loadData(window.BANDICOOT_DATA);

          // Re-emit data:loaded for any controllers that need it
          const processedData = DataLoader.process(window.BANDICOOT_DATA);
          if (processedData) {
            EventBus.emit('data:loaded', processedData);
          }
        }
      },

      /**
       * Show demo mode message when no token is available
       */
      _showDemoMode() {
        const mapContainer = document.getElementById('map');
        mapContainer.innerHTML = `
          <div style="
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-primary);
            color: var(--text-secondary);
            text-align: center;
            padding: var(--space-8);
          ">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="color: var(--accent-primary); margin-bottom: var(--space-4);">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
              <circle cx="12" cy="10" r="3"/>
            </svg>
            <h2 style="font-size: 20px; font-weight: 600; color: var(--text-primary); margin-bottom: var(--space-2);">
              Map Visualization
            </h2>
            <p style="font-size: 14px; max-width: 400px; line-height: 1.6; margin-bottom: var(--space-4);">
              Enter your Mapbox access token to display the interactive map.
            </p>
            <div style="
              display: flex;
              flex-direction: column;
              gap: var(--space-3);
              width: 100%;
              max-width: 400px;
            ">
              <input
                type="text"
                id="mapboxTokenInput"
                placeholder="pk.eyJ1Ijoi..."
                autocomplete="off"
                spellcheck="false"
                style="
                  width: 100%;
                  padding: var(--space-3) var(--space-4);
                  font-family: var(--font-mono);
                  font-size: 14px;
                  background: var(--bg-surface);
                  border: 1px solid var(--glass-border);
                  border-radius: var(--radius-md);
                  color: var(--text-primary);
                  outline: none;
                  transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
                "
                onfocus="this.style.borderColor='var(--accent-primary)'; this.style.boxShadow='0 0 0 2px var(--accent-glow)';"
                onblur="this.style.borderColor='var(--glass-border)'; this.style.boxShadow='none';"
              >
              <button
                id="mapboxTokenSubmit"
                style="
                  padding: var(--space-3) var(--space-6);
                  font-size: 14px;
                  font-weight: 500;
                  background: var(--accent-primary);
                  color: white;
                  border: none;
                  border-radius: var(--radius-md);
                  cursor: pointer;
                  transition: background var(--transition-fast), transform var(--transition-fast);
                "
                onmouseover="this.style.background='var(--accent-secondary)';"
                onmouseout="this.style.background='var(--accent-primary)';"
                onmousedown="this.style.transform='scale(0.98)';"
                onmouseup="this.style.transform='scale(1)';"
              >
                Load Map
              </button>
              <p id="mapboxTokenError" style="
                font-size: 12px;
                color: var(--color-call-out);
                display: none;
              "></p>
            </div>
            <p style="font-size: 12px; color: var(--text-muted); margin-top: var(--space-4); max-width: 400px;">
              Get a free token at <a href="https://mapbox.com" target="_blank" rel="noopener" style="color: var(--accent-primary);">mapbox.com</a>
            </p>
          </div>
        `;

        // Set up token input event handlers
        const tokenInput = document.getElementById('mapboxTokenInput');
        const tokenSubmit = document.getElementById('mapboxTokenSubmit');
        const tokenError = document.getElementById('mapboxTokenError');

        const handleTokenSubmit = () => {
          const token = tokenInput.value.trim();

          // Validate token format
          if (!token) {
            tokenError.textContent = 'Please enter a Mapbox access token.';
            tokenError.style.display = 'block';
            return;
          }

          if (!token.startsWith('pk.')) {
            tokenError.textContent = 'Token must start with "pk." (public token).';
            tokenError.style.display = 'block';
            return;
          }

          // Hide error and show loading state
          tokenError.style.display = 'none';
          tokenSubmit.textContent = 'Loading...';
          tokenSubmit.disabled = true;

          // Update config and reinitialize map
          CONFIG.MAPBOX_TOKEN = token;

          // Clear the container and reinitialize
          mapContainer.innerHTML = '';
          this.init().catch(error => {
            console.error('[MapController] Failed to initialize with token:', error);
            tokenError.textContent = 'Failed to load map. Please check your token.';
            tokenError.style.display = 'block';
            tokenSubmit.textContent = 'Load Map';
            tokenSubmit.disabled = false;
            this._showDemoMode();
          });
        };

        tokenSubmit.addEventListener('click', handleTokenSubmit);
        tokenInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleTokenSubmit();
          }
        });

        EventBus.emit('map:demo-mode');
      },

      /**
       * Handle theme changes by switching map style
       * @param {string} theme - 'dark' or 'light'
       */
      _handleThemeChange(theme) {
        if (!this.map) return;

        const style = theme === 'dark' ? CONFIG.MAPBOX_STYLE_DARK : CONFIG.MAPBOX_STYLE_LIGHT;

        // Mark style as loading
        this._isStyleLoading = true;

        // Change map style with smooth transition
        this.map.setStyle(style);

        // Wait for style to load, then reapply custom layers
        this.map.once('style.load', () => {
          this._isStyleLoading = false;
          this._reapplyLayers();
          this._processPendingOperations();
          console.log('[MapController] Style switched to:', theme);
        });
      },

      /**
       * Reapply custom data layers after style change
       */
      _reapplyLayers() {
        // Check if we have stored features
        if (!this._allFeatures || this._allFeatures.length === 0) {
          console.warn('[MapController] No features to reapply');
          return;
        }

        // Get currently filtered features from source if it exists
        const currentSource = this.map.getSource('events');
        let currentData = null;

        if (currentSource && currentSource._data) {
          currentData = currentSource._data;
        }

        // If we have current filtered data, use it; otherwise use all features
        const geojson = currentData || {
          type: 'FeatureCollection',
          features: this._allFeatures
        };

        // Reapply layers
        if (this.map.getSource('events')) {
          this.map.getSource('events').setData(geojson);
        } else {
          this._addDataLayers(geojson);
        }

        // Reapply current filters
        this.updateFilters();
      },

      /**
       * Process operations queued during style loading
       */
      _processPendingOperations() {
        while (this._pendingOperations.length > 0) {
          const operation = this._pendingOperations.shift();
          try {
            operation();
          } catch (error) {
            console.error('[MapController] Error processing pending operation:', error);
          }
        }
      },

      /**
       * Load GeoJSON data and create visualization layers
       * @param {Object} geojson - GeoJSON FeatureCollection
       */
      loadData(geojson) {
        if (!this.map) {
          console.warn('[MapController] Map not initialized');
          return;
        }

        if (this._isStyleLoading) {
          this._pendingOperations.push(() => this.loadData(geojson));
          return;
        }

        // Store original unfiltered features for source-level filtering
        this._allFeatures = geojson.features.slice();

        console.log('[MapController] Loading data:', geojson.features.length, 'features');

        // Remove existing layers and source if present
        this._removeDataLayers();

        // Add new layers
        this._addDataLayers(geojson);

        // Fit map to data bounds
        this._fitToBounds(geojson);

        EventBus.emit('map:data-loaded', { featureCount: geojson.features.length });
      },

      /**
       * Add data source and layers
       * @param {Object} geojson - GeoJSON FeatureCollection
       */
      _addDataLayers(geojson) {
        // Add clustered source
        this.map.addSource('events', {
          type: 'geojson',
          data: geojson,
          cluster: true,
          clusterMaxZoom: CONFIG.CLUSTER_MAX_ZOOM,
          clusterRadius: CONFIG.CLUSTER_RADIUS,
          clusterProperties: {
            // Aggregate counts by event type
            call_in: ['+', ['case', ['all',
              ['==', ['get', 'interaction_type'], 'call'],
              ['==', ['get', 'direction'], 'in']
            ], 1, 0]],
            call_out: ['+', ['case', ['all',
              ['==', ['get', 'interaction_type'], 'call'],
              ['==', ['get', 'direction'], 'out']
            ], 1, 0]],
            text_in: ['+', ['case', ['all',
              ['==', ['get', 'interaction_type'], 'text'],
              ['==', ['get', 'direction'], 'in']
            ], 1, 0]],
            text_out: ['+', ['case', ['all',
              ['==', ['get', 'interaction_type'], 'text'],
              ['==', ['get', 'direction'], 'out']
            ], 1, 0]]
          }
        });

        // Layer: Cluster circles with dynamic sizing and colors
        this.map.addLayer({
          id: 'clusters',
          type: 'circle',
          source: 'events',
          filter: ['has', 'point_count'],
          paint: {
            // Color based on cluster size
            'circle-color': [
              'step',
              ['get', 'point_count'],
              '#00d4ff',  // < 10
              10, '#7c3aed',  // 10-49
              50, '#ff6b6b',  // 50-99
              100, '#f59e0b'  // 100+
            ],
            // Size based on cluster size
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              20,   // < 10
              10, 26,   // 10-49
              50, 32,   // 50-99
              100, 40   // 100+
            ],
            'circle-stroke-width': 3,
            'circle-stroke-color': 'rgba(255, 255, 255, 0.25)',
            'circle-stroke-opacity': 1,
            // Smooth transitions
            'circle-opacity': [
              'interpolate',
              ['linear'],
              ['zoom'],
              0, 0.9,
              CONFIG.CLUSTER_MAX_ZOOM, 0.7
            ]
          }
        });

        // Layer: Cluster count labels
        this.map.addLayer({
          id: 'cluster-count',
          type: 'symbol',
          source: 'events',
          filter: ['has', 'point_count'],
          layout: {
            'text-field': ['get', 'point_count_abbreviated'],
            'text-font': ['DIN Pro Bold', 'Arial Unicode MS Bold'],
            'text-size': 13,
            'text-allow-overlap': true
          },
          paint: {
            'text-color': '#ffffff'
          }
        });

        // Layer: Individual event points
        this.map.addLayer({
          id: 'unclustered-point',
          type: 'circle',
          source: 'events',
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-radius': [
              'interpolate',
              ['linear'],
              ['zoom'],
              0, 4,
              10, 6,
              18, 10
            ],
            // Color based on event type
            'circle-color': [
              'match',
              ['concat', ['get', 'interaction_type'], '-', ['get', 'direction']],
              'call-in', '#10b981',
              'call-out', '#3b82f6',
              'text-in', '#f59e0b',
              'text-out', '#ec4899',
              '#00d4ff' // Default
            ],
            'circle-stroke-width': 2,
            'circle-stroke-color': 'rgba(255, 255, 255, 0.5)',
            'circle-opacity': 0.9
          }
        });

        // Add interactive cursors
        this.map.on('mouseenter', 'clusters', () => {
          this.map.getCanvas().style.cursor = 'pointer';
        });
        this.map.on('mouseleave', 'clusters', () => {
          this.map.getCanvas().style.cursor = '';
        });
        this.map.on('mouseenter', 'unclustered-point', () => {
          this.map.getCanvas().style.cursor = 'pointer';
        });
        this.map.on('mouseleave', 'unclustered-point', () => {
          this.map.getCanvas().style.cursor = '';
        });

        // Cluster click: zoom in
        this.map.on('click', 'clusters', (e) => this._handleClusterClick(e));

        // Point click: show popup
        this.map.on('click', 'unclustered-point', (e) => this._handlePointClick(e));

        // Map click: close popup when clicking empty areas
        // This handler runs after layer handlers; queryRenderedFeatures checks if we hit a feature
        this.map.on('click', (e) => {
          const features = this.map.queryRenderedFeatures(e.point, {
            layers: ['clusters', 'unclustered-point']
          });
          if (features.length === 0 && this.popup) {
            this.popup.remove();
            this.popup = null;
            this._activePopupKey = null;
          }
        });
      },

      /**
       * Remove data layers and source
       */
      _removeDataLayers() {
        const layers = ['unclustered-point', 'cluster-count', 'clusters'];
        layers.forEach(layer => {
          if (this.map.getLayer(layer)) {
            this.map.removeLayer(layer);
          }
        });
        if (this.map.getSource('events')) {
          this.map.removeSource('events');
        }
      },

      /**
       * Fit map view to data bounds
       * @param {Object} geojson - GeoJSON FeatureCollection
       */
      _fitToBounds(geojson) {
        if (!geojson.features.length) return;

        const bounds = new mapboxgl.LngLatBounds();
        geojson.features.forEach(feature => {
          if (feature.geometry && feature.geometry.coordinates) {
            bounds.extend(feature.geometry.coordinates);
          }
        });

        if (!bounds.isEmpty()) {
          this.map.fitBounds(bounds, {
            padding: { top: 100, bottom: 150, left: 350, right: 100 },
            maxZoom: 12,
            duration: 1000
          });
        }
      },

      /**
       * Handle cluster click - zoom to expand or show popup on Shift+click
       * @param {Object} e - Map click event
       */
      _handleClusterClick(e) {
        const features = this.map.queryRenderedFeatures(e.point, { layers: ['clusters'] });
        if (!features.length) return;

        const cluster = features[0];
        const clusterId = cluster.properties.cluster_id;
        const source = this.map.getSource('events');

        // Shift+click shows popup instead of zooming
        if (e.originalEvent.shiftKey) {
          this._showClusterPopup(cluster, source);
          return;
        }

        // Normal click: zoom to expand
        source.getClusterExpansionZoom(clusterId, (err, zoom) => {
          if (err) return;
          this.map.easeTo({
            center: cluster.geometry.coordinates,
            zoom: zoom + 1,
            duration: 500
          });
        });
      },

      /**
       * Show cluster summary popup with event breakdown
       * Clicking the same cluster again toggles the popup closed
       * @param {Object} cluster - Cluster feature
       * @param {Object} source - Map source
       */
      _showClusterPopup(cluster, source) {
        const count = cluster.properties.point_count;
        const coords = cluster.geometry.coordinates;
        const clusterId = cluster.properties.cluster_id;

        // Create unique key for this cluster
        const clusterKey = `cluster_${clusterId}`;

        // Toggle behavior: if clicking the same cluster, close the popup
        if (this.popup && this._activePopupKey === clusterKey) {
          this.popup.remove();
          this.popup = null;
          this._activePopupKey = null;
          return;
        }

        // Get cluster leaves to calculate breakdown
        source.getClusterLeaves(clusterId, 100, 0, (err, leaves) => {
          if (err) {
            console.error('[MapController] Error getting cluster leaves:', err);
            return;
          }

          // Calculate breakdown by type and direction
          const stats = {
            callIn: 0,
            callOut: 0,
            textIn: 0,
            textOut: 0
          };

          leaves.forEach(leaf => {
            const props = leaf.properties;
            const type = props.interaction_type;
            const dir = props.direction;
            if (type === 'call' && dir === 'in') stats.callIn++;
            else if (type === 'call' && dir === 'out') stats.callOut++;
            else if (type === 'text' && dir === 'in') stats.textIn++;
            else if (type === 'text' && dir === 'out') stats.textOut++;
          });

          // Build cluster popup HTML
          const html = `
            <div class="cluster-popup glass-panel">
              <div class="cluster-popup__header">
                <div class="cluster-popup__count">${count}</div>
                <div class="cluster-popup__label">Events in this area</div>
              </div>
              <div class="cluster-popup__breakdown">
                <div class="cluster-popup__stat">
                  <div class="cluster-popup__stat-color" style="background: var(--color-call-in);"></div>
                  <span class="cluster-popup__stat-value">${stats.callIn}</span>
                  <span class="cluster-popup__stat-type">Calls In</span>
                </div>
                <div class="cluster-popup__stat">
                  <div class="cluster-popup__stat-color" style="background: var(--color-call-out);"></div>
                  <span class="cluster-popup__stat-value">${stats.callOut}</span>
                  <span class="cluster-popup__stat-type">Calls Out</span>
                </div>
                <div class="cluster-popup__stat">
                  <div class="cluster-popup__stat-color" style="background: var(--color-text-in);"></div>
                  <span class="cluster-popup__stat-value">${stats.textIn}</span>
                  <span class="cluster-popup__stat-type">Texts In</span>
                </div>
                <div class="cluster-popup__stat">
                  <div class="cluster-popup__stat-color" style="background: var(--color-text-out);"></div>
                  <span class="cluster-popup__stat-value">${stats.textOut}</span>
                  <span class="cluster-popup__stat-type">Texts Out</span>
                </div>
              </div>
              <button class="cluster-popup__action" onclick="MapController._zoomToCluster('${clusterId}')">
                Zoom In
              </button>
            </div>
          `;

          // Remove existing popup
          if (this.popup) {
            this.popup.remove();
          }

          // Create and show popup
          this.popup = new mapboxgl.Popup({
            closeButton: false,
            closeOnClick: false,
            maxWidth: '280px',
            className: 'bandicoot-popup'
          })
            .setLngLat(coords)
            .setHTML(html)
            .addTo(this.map);

          // Track which cluster's popup is open for toggle behavior
          this._activePopupKey = clusterKey;

          // Clear tracking when popup is closed by other means
          this.popup.on('close', () => {
            this._activePopupKey = null;
          });
        });
      },

      /**
       * Zoom to cluster (called from popup button)
       * @param {string} clusterId - Cluster ID
       */
      _zoomToCluster(clusterId) {
        const source = this.map.getSource('events');
        if (!source) return;

        source.getClusterExpansionZoom(parseInt(clusterId), (err, zoom) => {
          if (err) return;

          // Get cluster coordinates from rendered features
          const clusters = this.map.queryRenderedFeatures({ layers: ['clusters'] });
          const cluster = clusters.find(c => c.properties.cluster_id === parseInt(clusterId));

          if (cluster) {
            // Close popup first
            if (this.popup) {
              this.popup.remove();
            }

            this.map.easeTo({
              center: cluster.geometry.coordinates,
              zoom: zoom + 1,
              duration: 500
            });
          }
        });
      },

      /**
       * Handle individual point click - show rich event popup
       * Clicking the same marker again toggles the popup closed
       * @param {Object} e - Map click event
       */
      _handlePointClick(e) {
        const feature = e.features[0];
        const props = feature.properties;
        const coords = feature.geometry.coordinates;

        // Create unique key for this feature based on coordinates
        const featureKey = `point_${coords[0]}_${coords[1]}`;

        // Toggle behavior: if clicking the same marker, close the popup
        if (this.popup && this._activePopupKey === featureKey) {
          this.popup.remove();
          this.popup = null;
          this._activePopupKey = null;
          return;
        }

        // Determine event type and direction
        const type = props.interaction_type;
        const dir = props.direction;
        const iconClass = `event-popup__icon--${type}-${dir}`;
        const typeLabel = `${dir === 'in' ? 'Incoming' : 'Outgoing'} ${type === 'call' ? 'Call' : 'Text'}`;

        // Format timestamp
        const date = new Date(props.timestamp);
        const dateStr = date.toLocaleDateString('en-US', {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
        const timeStr = date.toLocaleTimeString('en-US', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
          hour12: false
        });

        // Duration row for calls
        const durationHtml = type === 'call' && props.duration ? `
          <div class="event-popup__row">
            <span class="event-popup__label">Duration</span>
            <span class="event-popup__value">${this._formatDuration(props.duration)}</span>
          </div>
        ` : '';

        // Build rich popup HTML
        const html = `
          <div class="event-popup glass-panel">
            <div class="event-popup__header">
              <div class="event-popup__icon ${iconClass}">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                  ${type === 'call'
                    ? '<path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.48-3.9-6.89-6.83l1.95-1.66c.27-.28.35-.67.24-1.02-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19C3.65 3 3 3.24 3 3.99 3 13.28 10.73 21 20.01 21c.71 0 .99-.63.99-1.18v-3.45c0-.54-.45-.99-.99-.99z"/>'
                    : '<path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>'
                  }
                </svg>
              </div>
              <div class="event-popup__type">${typeLabel}</div>
            </div>
            <div class="event-popup__body">
              <div class="event-popup__row">
                <span class="event-popup__label">Date</span>
                <span class="event-popup__value">${dateStr}</span>
              </div>
              <div class="event-popup__row">
                <span class="event-popup__label">Time</span>
                <span class="event-popup__value">${timeStr}</span>
              </div>
              ${durationHtml}
              <div class="event-popup__row">
                <span class="event-popup__label">Contact</span>
                <span class="event-popup__value">${props.correspondent_id || 'Unknown'}</span>
              </div>
              <div class="event-popup__row">
                <span class="event-popup__label">Antenna</span>
                <span class="event-popup__value">${props.antenna_id || 'Unknown'}</span>
              </div>
            </div>
          </div>
        `;

        // Remove existing popup
        if (this.popup) {
          this.popup.remove();
        }

        // Determine best anchor position based on marker location on screen
        const point = this.map.project(feature.geometry.coordinates);
        const anchor = this._determinePopupAnchor(point);

        // Create and show new popup with offset and smart anchor
        this.popup = new mapboxgl.Popup({
          closeButton: false,
          closeOnClick: false,
          maxWidth: CONFIG.POPUP_MAX_WIDTH,
          className: 'bandicoot-popup',
          offset: 15,
          anchor: anchor
        })
          .setLngLat(feature.geometry.coordinates)
          .setHTML(html)
          .addTo(this.map);

        // Track which feature's popup is open for toggle behavior
        this._activePopupKey = featureKey;

        // Clear tracking when popup is closed by other means (e.g., clicking elsewhere)
        this.popup.on('close', () => {
          this._activePopupKey = null;
        });
      },

      /**
       * Determine optimal popup anchor based on marker screen position
       * Avoids control panels and viewport edges
       * @param {Object} point - Screen coordinates {x, y}
       * @returns {string} Anchor position for Mapbox popup
       */
      _determinePopupAnchor(point) {
        const mapContainer = this.map.getContainer();
        const width = mapContainer.offsetWidth;
        const height = mapContainer.offsetHeight;

        // Control panel dimensions (approximate)
        const leftPanelWidth = 300;   // Contact filter panel
        const topPanelHeight = 150;   // Clock display
        const bottomPanelHeight = 200; // Timeline controls

        // Check if marker is near control panels or edges
        const nearLeft = point.x < leftPanelWidth + 50;
        const nearTop = point.y < topPanelHeight + 50;
        const nearBottom = point.y > height - bottomPanelHeight - 50;
        const nearRight = point.x > width - 50;

        // Determine best anchor to keep popup visible and away from controls
        if (nearLeft && nearTop) return 'top-left';
        if (nearLeft && nearBottom) return 'bottom-left';
        if (nearLeft) return 'left';

        if (nearRight && nearTop) return 'top-right';
        if (nearRight && nearBottom) return 'bottom-right';
        if (nearRight) return 'right';

        if (nearTop) return 'top';
        if (nearBottom) return 'bottom';

        // Default to bottom (popup appears above marker)
        return 'bottom';
      },

      /**
       * Format duration in seconds to readable string
       * @param {number} seconds - Duration in seconds
       * @returns {string} Formatted duration (e.g., "5m 30s")
       */
      _formatDuration(seconds) {
        if (!seconds || seconds < 0) return '0s';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        if (mins > 0) {
          return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
        }
        return `${secs}s`;
      },

      /**
       * Update map filters based on current state
       * Filters features in JS and updates source data (not layer filters)
       * This ensures clusters update correctly
       */
      updateFilters() {
        if (!this.map || !this.map.getSource('events')) {
          console.warn('[MapController] Cannot update filters - map or source not ready');
          return;
        }

        if (this._isStyleLoading) {
          this._pendingOperations.push(() => this.updateFilters());
          return;
        }

        if (!this._allFeatures) {
          console.warn('[MapController] No features to filter');
          return;
        }

        const currentTime = State.get('time.current');
        const selectedContacts = State.get('contacts.selected');
        const contactMode = State.get('contacts.mode');

        console.log('[MapController] Applying filters:', {
          currentTime,
          contactCount: selectedContacts.length,
          contactMode,
          totalFeatures: this._allFeatures.length
        });

        // Filter features in JavaScript
        let filteredFeatures = this._allFeatures;

        // Apply time filter
        if (typeof currentTime === 'number' && !isNaN(currentTime)) {
          filteredFeatures = filteredFeatures.filter(feature => {
            const timestamp = feature.properties?.timestamp;
            return timestamp != null && timestamp <= currentTime;
          });
        }

        // Apply contact filter
        if (contactMode === 'none' || (contactMode !== 'all' && selectedContacts.length === 0)) {
          // Hide all contacts
          filteredFeatures = [];
        } else if (contactMode !== 'all' && selectedContacts.length > 0) {
          // Show only selected contacts
          filteredFeatures = filteredFeatures.filter(feature => {
            const contactId = feature.properties?.correspondent_id;
            return contactId != null && selectedContacts.includes(contactId);
          });
        }
        // If contactMode === 'all', show all (no filtering needed)

        console.log('[MapController] Filtered:', filteredFeatures.length, 'features');

        // Update source data with filtered features
        // This triggers re-clustering automatically
        const source = this.map.getSource('events');
        if (source) {
          source.setData({
            type: 'FeatureCollection',
            features: filteredFeatures
          });
        }

        // Remove any layer filters since we're filtering at source level
        // Clusters and points now only show filtered data
        if (this.map.getLayer('unclustered-point')) {
          this.map.setFilter('unclustered-point', ['!', ['has', 'point_count']]);
        }
        if (this.map.getLayer('clusters')) {
          this.map.setFilter('clusters', ['has', 'point_count']);
        }
        if (this.map.getLayer('cluster-count')) {
          this.map.setFilter('cluster-count', ['has', 'point_count']);
        }
      },

      /**
       * Fly to a specific location
       * @param {Array} center - [lng, lat]
       * @param {number} zoom - Zoom level
       */
      flyTo(center, zoom = 12) {
        if (!this.map) return;
        this.map.flyTo({
          center,
          zoom,
          duration: 1500,
          essential: true
        });
      },

      /**
       * Get the map instance
       * @returns {Object} Mapbox map instance
       */
      getMap() {
        return this.map;
      }
    };

    // ============================================================
    // MODULE: TimeController
    // Manages time playback, animation, and clock display
    // Could be extracted to: js/controllers/TimeController.js
    // ============================================================
    const TimeController = {
      animationId: null,
      lastFrameTime: 0,

      /**
       * Initialize time controller
       */
      init() {
        console.log('[TimeController] Initializing...');

        // Listen for data loaded to set time range
        EventBus.on('data:loaded', ({ timeRange }) => {
          console.log('[TimeController] Data loaded with time range:', timeRange);
          State.set('time.start', timeRange.start);
          State.set('time.end', timeRange.end);
          // Set current time to END of range so all data is visible initially
          State.set('time.current', timeRange.end);
          this.updateClock(timeRange.end);
          TimeSlider.updatePosition(timeRange.end);
          TimeSlider.updateLabels(timeRange.start, timeRange.end);
          // Emit filter update to apply the new time filter
          EventBus.emit('filter:update');
        });

        // Play/Pause button
        const playPauseBtn = document.getElementById('playPause');
        if (playPauseBtn) {
          playPauseBtn.addEventListener('click', () => this.togglePlay());
        }

        // Speed buttons
        document.querySelectorAll('.time-controls__speed-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            document.querySelectorAll('.time-controls__speed-btn').forEach(b =>
              b.classList.remove('time-controls__speed-btn--active'));
            btn.classList.add('time-controls__speed-btn--active');
            State.set('time.speed', parseFloat(btn.dataset.speed));
            console.log('[TimeController] Speed set to:', btn.dataset.speed);
          });
        });

        // Step buttons
        const stepBackBtn = document.getElementById('stepBack');
        const stepForwardBtn = document.getElementById('stepForward');

        if (stepBackBtn) {
          stepBackBtn.addEventListener('click', () => this.step(-1));
        }
        if (stepForwardBtn) {
          stepForwardBtn.addEventListener('click', () => this.step(1));
        }

        // Listen for seek events from slider
        EventBus.on('time:seek', ({ timestamp }) => {
          State.set('time.current', timestamp);
          this.updateClock(timestamp);
          EventBus.emit('filter:update');
        });

        console.log('[TimeController] Initialized');
      },

      /**
       * Toggle play/pause state
       */
      togglePlay() {
        const isPlaying = State.get('time.isPlaying');
        if (isPlaying) {
          this.pause();
        } else {
          this.play();
        }
      },

      /**
       * Start time animation playback
       */
      play() {
        // Check if we have valid time data
        const start = State.get('time.start');
        const end = State.get('time.end');

        if (start === null || end === null) {
          console.warn('[TimeController] Cannot play - no time data loaded');
          return;
        }

        State.set('time.isPlaying', true);

        // Update button icons
        const playIcon = document.querySelector('.play-icon');
        const pauseIcon = document.querySelector('.pause-icon');
        const playBtn = document.getElementById('playPause');

        if (playIcon) playIcon.style.display = 'none';
        if (pauseIcon) pauseIcon.style.display = 'block';
        if (playBtn) playBtn.classList.add('is-playing');

        this.lastFrameTime = performance.now();
        this.animate();

        console.log('[TimeController] Playback started');
      },

      /**
       * Pause time animation
       */
      pause() {
        State.set('time.isPlaying', false);

        // Update button icons
        const playIcon = document.querySelector('.play-icon');
        const pauseIcon = document.querySelector('.pause-icon');
        const playBtn = document.getElementById('playPause');

        if (playIcon) playIcon.style.display = 'block';
        if (pauseIcon) pauseIcon.style.display = 'none';
        if (playBtn) playBtn.classList.remove('is-playing');

        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }

        console.log('[TimeController] Playback paused');
      },

      /**
       * Animation frame loop
       */
      animate() {
        if (!State.get('time.isPlaying')) return;

        const now = performance.now();
        const delta = now - this.lastFrameTime;
        this.lastFrameTime = now;

        const speed = State.get('time.speed');
        const current = State.get('time.current');
        const end = State.get('time.end');

        // Each real second = 1 hour of data time at 1x speed
        const dataTimeDelta = (delta / 1000) * CONFIG.TIME_SCALE_FACTOR * speed;
        const newTime = Math.min(current + dataTimeDelta, end);

        State.set('time.current', newTime);
        this.updateClock(newTime);
        TimeSlider.updatePosition(newTime);
        EventBus.emit('filter:update');

        if (newTime >= end) {
          this.pause();
          console.log('[TimeController] Playback complete - reached end of data');
        } else {
          this.animationId = requestAnimationFrame(() => this.animate());
        }
      },

      /**
       * Step forward or backward by a fixed amount
       * @param {number} direction - 1 for forward, -1 for backward
       */
      step(direction) {
        const current = State.get('time.current');
        const start = State.get('time.start');
        const end = State.get('time.end');

        if (start === null || end === null) {
          console.warn('[TimeController] Cannot step - no time data loaded');
          return;
        }

        const stepSize = 3600000; // 1 hour in milliseconds
        const newTime = Math.max(start, Math.min(end, current + (stepSize * direction)));

        EventBus.emit('time:seek', { timestamp: newTime });
        TimeSlider.updatePosition(newTime);

        console.log('[TimeController] Stepped', direction > 0 ? 'forward' : 'backward');
      },

      /**
       * Update the world clock display
       * @param {number} timestamp - Unix timestamp in milliseconds
       */
      updateClock(timestamp) {
        if (timestamp === null) return;

        const date = new Date(timestamp);

        // Update date display
        const dateStr = date.toLocaleDateString('en-US', {
          weekday: 'short',
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });
        const clockDateEl = document.getElementById('clockDate');
        if (clockDateEl) clockDateEl.textContent = dateStr;

        // Extract time components
        const hours = String(date.getHours()).padStart(2, '0');
        const mins = String(date.getMinutes()).padStart(2, '0');
        const secs = String(date.getSeconds()).padStart(2, '0');

        // Update digits with flip animation
        this.updateDigit('hour1', hours[0]);
        this.updateDigit('hour2', hours[1]);
        this.updateDigit('min1', mins[0]);
        this.updateDigit('min2', mins[1]);
        this.updateDigit('sec1', secs[0]);
        this.updateDigit('sec2', secs[1]);

        // Update timezone display
        const timezoneEl = document.getElementById('clockTimezone');
        if (timezoneEl) {
          try {
            timezoneEl.textContent = Intl.DateTimeFormat().resolvedOptions().timeZone;
          } catch (e) {
            timezoneEl.textContent = 'Local Time';
          }
        }

        // Update slider current time tooltip
        const sliderCurrentEl = document.getElementById('sliderCurrentTime');
        if (sliderCurrentEl) {
          sliderCurrentEl.textContent = `${hours}:${mins}:${secs}`;
        }
      },

      /**
       * Update a single digit with flip animation if changed
       * @param {string} id - Element ID
       * @param {string} value - New digit value
       */
      updateDigit(id, value) {
        const el = document.getElementById(id);
        if (!el) return;

        if (el.textContent !== value) {
          el.classList.add('world-clock__digit--flip');
          el.textContent = value;
          setTimeout(() => el.classList.remove('world-clock__digit--flip'), 200);
        }
      }
    };

    // ============================================================
    // MODULE: TimeSlider
    // Handles time slider interactions and visualization
    // Could be extracted to: js/components/TimeSlider.js
    // ============================================================
    const TimeSlider = {
      isDragging: false,
      sliderEl: null,
      trackEl: null,
      handleEl: null,
      progressEl: null,

      /**
       * Initialize time slider
       */
      init() {
        console.log('[TimeSlider] Initializing...');

        this.sliderEl = document.getElementById('timeSlider');
        this.trackEl = this.sliderEl?.querySelector('.time-slider__track');
        this.handleEl = document.getElementById('sliderHandle');
        this.progressEl = document.getElementById('sliderProgress');

        if (!this.sliderEl || !this.trackEl || !this.handleEl) {
          console.warn('[TimeSlider] Required elements not found');
          return;
        }

        // Handle drag start
        this.handleEl.addEventListener('mousedown', (e) => this.startDrag(e));
        this.handleEl.addEventListener('touchstart', (e) => this.startDrag(e), { passive: false });

        // Track click for direct seek
        this.trackEl.addEventListener('click', (e) => this.handleTrackClick(e));

        // Global mouse/touch move and end
        document.addEventListener('mousemove', (e) => this.drag(e));
        document.addEventListener('mouseup', () => this.endDrag());
        document.addEventListener('touchmove', (e) => this.drag(e), { passive: false });
        document.addEventListener('touchend', () => this.endDrag());

        // Listen for data loaded event to render density
        EventBus.on('data:loaded', ({ density }) => {
          if (density) {
            this.renderDensity(density);
          }
        });

        console.log('[TimeSlider] Initialized');
      },

      /**
       * Start dragging the slider handle
       * @param {Event} e - Mouse or touch event
       */
      startDrag(e) {
        e.preventDefault();
        this.isDragging = true;

        if (this.handleEl) {
          this.handleEl.classList.add('is-dragging');
        }

        // Pause playback while dragging
        if (State.get('time.isPlaying')) {
          TimeController.pause();
        }
      },

      /**
       * Handle drag movement
       * @param {Event} e - Mouse or touch event
       */
      drag(e) {
        if (!this.isDragging || !this.trackEl) return;

        const rect = this.trackEl.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const position = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));

        const start = State.get('time.start');
        const end = State.get('time.end');

        if (start === null || end === null) return;

        const timestamp = start + (end - start) * position;
        EventBus.emit('time:seek', { timestamp });
        this.updatePosition(timestamp);
      },

      /**
       * End dragging
       */
      endDrag() {
        if (!this.isDragging) return;

        this.isDragging = false;

        if (this.handleEl) {
          this.handleEl.classList.remove('is-dragging');
        }
      },

      /**
       * Handle direct click on the track
       * @param {Event} e - Click event
       */
      handleTrackClick(e) {
        if (this.isDragging) return;

        const rect = this.trackEl.getBoundingClientRect();
        const position = (e.clientX - rect.left) / rect.width;

        const start = State.get('time.start');
        const end = State.get('time.end');

        if (start === null || end === null) return;

        const timestamp = start + (end - start) * Math.max(0, Math.min(1, position));
        EventBus.emit('time:seek', { timestamp });
        this.updatePosition(timestamp);
      },

      /**
       * Update slider position based on timestamp
       * @param {number} timestamp - Current time in milliseconds
       */
      updatePosition(timestamp) {
        const start = State.get('time.start');
        const end = State.get('time.end');

        if (start === null || end === null || !this.handleEl || !this.progressEl) return;

        const position = ((timestamp - start) / (end - start)) * 100;
        const clampedPosition = Math.max(0, Math.min(100, position));

        this.handleEl.style.left = `${clampedPosition}%`;
        this.progressEl.style.width = `${clampedPosition}%`;
      },

      /**
       * Render event density on the slider track
       * @param {Array} density - Array of {timestamp, count} objects
       */
      renderDensity(density) {
        if (!density || density.length === 0) return;

        const densityEl = document.getElementById('sliderDensity');
        if (!densityEl) return;

        const maxCount = Math.max(...density.map(d => d.count));

        const stops = density.map((d, i) => {
          const position = (i / (density.length - 1)) * 100;
          const intensity = d.count / maxCount;
          const alpha = 0.1 + intensity * 0.5;
          return `rgba(0, 212, 255, ${alpha}) ${position}%`;
        });

        densityEl.style.background = `linear-gradient(to right, ${stops.join(', ')})`;
        console.log('[TimeSlider] Density gradient rendered');
      },

      /**
       * Update start/end labels
       * @param {number} start - Start timestamp
       * @param {number} end - End timestamp
       */
      updateLabels(start, end) {
        const formatDate = (ts) => new Date(ts).toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric',
          year: 'numeric'
        });

        const startLabelEl = document.getElementById('sliderLabelStart');
        const endLabelEl = document.getElementById('sliderLabelEnd');

        if (startLabelEl) startLabelEl.textContent = formatDate(start);
        if (endLabelEl) endLabelEl.textContent = formatDate(end);
      }
    };

    // ============================================================
    // MODULE: DataLoader
    // Processes and prepares data for visualization
    // Could be extracted to: js/data/DataLoader.js
    // ============================================================
    const DataLoader = {
      /**
       * Process GeoJSON data and extract metadata
       * @param {Object} geojson - GeoJSON FeatureCollection
       * @returns {Object} Processed data with metadata
       */
      process(geojson) {
        console.log('[DataLoader] Processing data...');

        if (!geojson || !geojson.features || geojson.features.length === 0) {
          console.warn('[DataLoader] No features to process');
          return null;
        }

        const features = geojson.features;

        // Extract time range
        const timestamps = features
          .map(f => f.properties?.timestamp)
          .filter(ts => ts != null)
          .sort((a, b) => a - b);

        const timeRange = {
          start: timestamps[0] || Date.now(),
          end: timestamps[timestamps.length - 1] || Date.now()
        };

        // Extract unique contacts with stats
        const contactMap = new Map();
        features.forEach(f => {
          const id = f.properties?.correspondent_id;
          if (!id) return;

          if (!contactMap.has(id)) {
            contactMap.set(id, { id, calls: 0, texts: 0, total: 0 });
          }

          const contact = contactMap.get(id);
          if (f.properties?.interaction_type === 'call') {
            contact.calls++;
          } else {
            contact.texts++;
          }
          contact.total++;
        });

        const contacts = Array.from(contactMap.values())
          .sort((a, b) => b.total - a.total);

        // Calculate event density for slider visualization
        const density = this.calculateDensity(timestamps, 50);

        // Store features in state
        State.set('data.features', features);
        State.set('data.loaded', true);
        State.set('contacts.all', contacts.map(c => c.id));
        State.set('contacts.selected', contacts.map(c => c.id));

        console.log('[DataLoader] Processed:', {
          featureCount: features.length,
          contactCount: contacts.length,
          timeRange
        });

        // Update event count badge
        const eventCountEl = document.getElementById('eventCount');
        if (eventCountEl) {
          eventCountEl.textContent = features.length.toLocaleString();
        }

        return { features, timeRange, contacts, density };
      },

      /**
       * Calculate event density over time
       * @param {Array} timestamps - Sorted array of timestamps
       * @param {number} buckets - Number of buckets
       * @returns {Array} Density data
       */
      calculateDensity(timestamps, buckets) {
        if (!timestamps.length) return [];

        const start = timestamps[0];
        const end = timestamps[timestamps.length - 1];
        const range = end - start;
        const bucketSize = range / buckets;

        const density = Array(buckets).fill(0).map((_, i) => ({
          timestamp: start + (i * bucketSize),
          count: 0
        }));

        timestamps.forEach(ts => {
          const bucketIndex = Math.min(
            Math.floor((ts - start) / bucketSize),
            buckets - 1
          );
          if (bucketIndex >= 0 && bucketIndex < buckets) {
            density[bucketIndex].count++;
          }
        });

        return density;
      }
    };

    // ============================================================
    // MODULE: ContactFilter
    // Multi-select dropdown for filtering events by contact
    // Could be extracted to: js/components/ContactFilter.js
    // ============================================================
    const ContactFilter = {
      /** @type {Array<{id: string, calls: number, texts: number, total: number}>} */
      contacts: [],

      /**
       * Initialize the contact filter component
       */
      init() {
        console.log('[ContactFilter] Initializing...');

        // Listen for data loaded event
        EventBus.on('data:loaded', ({ contacts }) => {
          console.log('[ContactFilter] Data loaded, rendering contacts:', contacts.length);
          this.contacts = contacts;
          this.render();
          this.updateCount();
        });

        // Search input with debounce
        const searchInput = document.getElementById('contactSearch');
        if (searchInput) {
          let debounceTimer;
          searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
              this.filterList(e.target.value);
            }, 150);
          });
        }

        // Preset buttons (All, Top 10, None)
        document.querySelectorAll('.contact-filter__preset').forEach(btn => {
          btn.addEventListener('click', () => {
            this.handlePreset(btn.dataset.preset);
          });
        });

        console.log('[ContactFilter] Initialized');
      },

      /**
       * Render the contact list with stats
       */
      render() {
        const list = document.getElementById('contactList');
        const emptyEl = document.getElementById('contactListEmpty');

        if (!list) {
          console.warn('[ContactFilter] Contact list element not found');
          return;
        }

        // Clear existing items (but keep the empty state element)
        Array.from(list.children).forEach(child => {
          if (child.id !== 'contactListEmpty') {
            child.remove();
          }
        });

        // Hide empty state if we have contacts
        if (emptyEl) {
          emptyEl.style.display = this.contacts.length === 0 ? 'block' : 'none';
        }

        // Render each contact
        this.contacts.forEach((contact, index) => {
          const item = document.createElement('div');
          item.className = 'contact-filter__item contact-filter__item--selected';
          item.dataset.id = contact.id;
          item.style.animationDelay = `${index * 30}ms`;

          item.innerHTML = `
            <div class="contact-filter__checkbox">
              <svg class="contact-filter__checkbox-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"/>
              </svg>
            </div>
            <div class="contact-filter__contact-info">
              <div class="contact-filter__contact-id">${this.escapeHtml(contact.id)}</div>
              <div class="contact-filter__contact-stats">
                <span class="contact-filter__stat">
                  <span class="contact-filter__stat-dot contact-filter__stat-dot--calls"></span>
                  ${contact.calls}
                </span>
                <span class="contact-filter__stat">
                  <span class="contact-filter__stat-dot contact-filter__stat-dot--texts"></span>
                  ${contact.texts}
                </span>
              </div>
            </div>
          `;

          // Click handler for toggling selection
          item.addEventListener('click', () => this.toggleContact(contact.id, item));
          list.appendChild(item);
        });

        console.log('[ContactFilter] Rendered', this.contacts.length, 'contacts');
      },

      /**
       * Escape HTML special characters for safe rendering
       * @param {string} str - Input string
       * @returns {string} Escaped string
       */
      escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      },

      /**
       * Toggle contact selection
       * @param {string} id - Contact ID
       * @param {HTMLElement} item - Contact item element
       */
      toggleContact(id, item) {
        item.classList.toggle('contact-filter__item--selected');
        const selected = State.get('contacts.selected') || [];

        if (item.classList.contains('contact-filter__item--selected')) {
          // Add to selection
          if (!selected.includes(id)) {
            State.set('contacts.selected', [...selected, id]);
          }
        } else {
          // Remove from selection
          State.set('contacts.selected', selected.filter(c => c !== id));
        }

        // Update mode to custom selection
        State.set('contacts.mode', 'selected');
        this.updatePresetButtons('');
        this.updateCount();

        // Emit filter update event
        EventBus.emit('filter:update');
      },

      /**
       * Handle preset button clicks (All, Top 10, None)
       * @param {string} preset - Preset name
       */
      handlePreset(preset) {
        console.log('[ContactFilter] Applying preset:', preset);
        this.updatePresetButtons(preset);
        const items = document.querySelectorAll('.contact-filter__item');

        switch (preset) {
          case 'all':
            items.forEach(item => item.classList.add('contact-filter__item--selected'));
            State.set('contacts.mode', 'all');
            State.set('contacts.selected', this.contacts.map(c => c.id));
            break;

          case 'none':
            items.forEach(item => item.classList.remove('contact-filter__item--selected'));
            State.set('contacts.mode', 'selected');
            State.set('contacts.selected', []);
            break;

          case 'top10':
            const top10 = this.contacts.slice(0, 10).map(c => c.id);
            items.forEach(item => {
              if (top10.includes(item.dataset.id)) {
                item.classList.add('contact-filter__item--selected');
              } else {
                item.classList.remove('contact-filter__item--selected');
              }
            });
            State.set('contacts.mode', 'selected');
            State.set('contacts.selected', top10);
            break;
        }

        this.updateCount();
        EventBus.emit('filter:update');
      },

      /**
       * Update preset button active states
       * @param {string} active - Active preset name (or empty string for none)
       */
      updatePresetButtons(active) {
        document.querySelectorAll('.contact-filter__preset').forEach(btn => {
          const isActive = btn.dataset.preset === active;
          btn.classList.toggle('contact-filter__preset--active', isActive);
        });
      },

      /**
       * Filter the contact list by search query
       * @param {string} query - Search query
       */
      filterList(query) {
        const items = document.querySelectorAll('.contact-filter__item');
        const lowerQuery = query.toLowerCase().trim();

        let visibleCount = 0;
        items.forEach(item => {
          const id = (item.dataset.id || '').toLowerCase();
          const matches = lowerQuery === '' || id.includes(lowerQuery);
          item.style.display = matches ? 'flex' : 'none';
          if (matches) visibleCount++;
        });

        // Update empty state
        const emptyEl = document.getElementById('contactListEmpty');
        if (emptyEl) {
          if (visibleCount === 0 && this.contacts.length > 0) {
            emptyEl.style.display = 'block';
            emptyEl.textContent = 'No matching contacts';
          } else if (this.contacts.length === 0) {
            emptyEl.style.display = 'block';
            emptyEl.textContent = 'No contacts loaded';
          } else {
            emptyEl.style.display = 'none';
          }
        }
      },

      /**
       * Update the selected/total count display
       */
      updateCount() {
        const selected = document.querySelectorAll('.contact-filter__item--selected').length;
        const total = this.contacts.length;
        const countEl = document.getElementById('contactCount');

        if (countEl) {
          countEl.textContent = `${selected}/${total}`;

          // Add visual feedback for selection state
          if (selected === 0) {
            countEl.style.color = 'var(--accent-secondary)';
          } else if (selected === total) {
            countEl.style.color = 'var(--accent-primary)';
          } else {
            countEl.style.color = 'var(--text-secondary)';
          }
        }
      }
    };

    // ============================================================
    // MODULE: DateTimePicker
    // Calendar-based date range selection with preset options
    // Could be extracted to: js/components/DateTimePicker.js
    // ============================================================
    const DateTimePicker = {
      /** @type {boolean} Whether the dropdown is open */
      isOpen: false,

      /** @type {Date} Currently displayed month in calendar */
      currentMonth: new Date(),

      /** @type {{start: number|null, end: number|null}} Data time range bounds */
      dataRange: { start: null, end: null },

      /**
       * Initialize the date/time picker component
       */
      init() {
        console.log('[DateTimePicker] Initializing...');

        const trigger = document.getElementById('dateTimePickerTrigger');
        const pickerEl = document.getElementById('dateTimePicker');

        if (!trigger || !pickerEl) {
          console.warn('[DateTimePicker] Required elements not found');
          return;
        }

        // Toggle dropdown on trigger click
        trigger.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggle();
        });

        // Close on outside click
        document.addEventListener('click', (e) => {
          if (!e.target.closest('.datetime-picker') && this.isOpen) {
            this.close();
          }
        });

        // Escape key closes dropdown
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && this.isOpen) {
            this.close();
          }
        });

        // Month navigation
        const prevBtn = document.getElementById('calendarPrev');
        const nextBtn = document.getElementById('calendarNext');

        if (prevBtn) {
          prevBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.navigateMonth(-1);
          });
        }

        if (nextBtn) {
          nextBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.navigateMonth(1);
          });
        }

        // Preset buttons
        document.querySelectorAll('.datetime-picker__preset').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.handlePreset(btn.dataset.preset);
          });
        });

        // Listen for data loaded event
        EventBus.on('data:loaded', ({ timeRange }) => {
          console.log('[DateTimePicker] Data loaded, time range:', timeRange);
          this.dataRange = timeRange;
          this.currentMonth = new Date(timeRange.start);
          this.updateTriggerText();
        });

        console.log('[DateTimePicker] Initialized');
      },

      /**
       * Toggle the dropdown open/closed
       */
      toggle() {
        if (this.isOpen) {
          this.close();
        } else {
          this.open();
        }
      },

      /**
       * Open the dropdown and render calendar
       */
      open() {
        this.isOpen = true;
        const pickerEl = document.getElementById('dateTimePicker');
        if (pickerEl) {
          pickerEl.classList.add('datetime-picker--open');
        }
        this.renderCalendar();
        console.log('[DateTimePicker] Opened');
      },

      /**
       * Close the dropdown
       */
      close() {
        this.isOpen = false;
        const pickerEl = document.getElementById('dateTimePicker');
        if (pickerEl) {
          pickerEl.classList.remove('datetime-picker--open');
        }
        console.log('[DateTimePicker] Closed');
      },

      /**
       * Navigate to previous/next month
       * @param {number} delta - Number of months to move (-1 or 1)
       */
      navigateMonth(delta) {
        this.currentMonth.setMonth(this.currentMonth.getMonth() + delta);
        this.renderCalendar();
      },

      /**
       * Render the calendar grid for the current month
       */
      renderCalendar() {
        const year = this.currentMonth.getFullYear();
        const month = this.currentMonth.getMonth();

        // Update month/year display
        const monthYearEl = document.getElementById('calendarMonthYear');
        if (monthYearEl) {
          monthYearEl.textContent = this.currentMonth.toLocaleDateString('en-US', {
            month: 'long',
            year: 'numeric'
          });
        }

        // Calculate calendar grid
        const firstDay = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const daysInPrevMonth = new Date(year, month, 0).getDate();

        const container = document.getElementById('calendarDays');
        if (!container) return;

        container.innerHTML = '';

        const today = new Date();
        const currentStart = State.get('time.start');
        const currentEnd = State.get('time.end');

        // Previous month days
        for (let i = firstDay - 1; i >= 0; i--) {
          const day = daysInPrevMonth - i;
          const el = this.createDayElement(day, ['other-month']);
          container.appendChild(el);
        }

        // Current month days
        for (let day = 1; day <= daysInMonth; day++) {
          const date = new Date(year, month, day);
          const timestamp = date.getTime();
          const classes = [];

          // Check if today
          if (date.toDateString() === today.toDateString()) {
            classes.push('today');
          }

          // Check if date has data
          if (this.dataRange.start && this.dataRange.end) {
            const dayStart = timestamp;
            const dayEnd = timestamp + 86400000 - 1;
            if (dayEnd >= this.dataRange.start && dayStart <= this.dataRange.end) {
              classes.push('has-data');
            }
          }

          // Check if selected
          if (currentStart && currentEnd) {
            const dayStart = timestamp;
            const dayEnd = timestamp + 86400000 - 1;
            if (dayStart >= currentStart && dayEnd <= currentEnd) {
              classes.push('in-range');
            }
            if (new Date(currentStart).toDateString() === date.toDateString()) {
              classes.push('selected');
            }
          }

          const el = this.createDayElement(day, classes);
          el.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectDate(date);
          });
          container.appendChild(el);
        }

        // Next month days to fill grid
        const totalCells = 42;
        const remaining = totalCells - container.children.length;
        for (let day = 1; day <= remaining; day++) {
          const el = this.createDayElement(day, ['other-month']);
          container.appendChild(el);
        }
      },

      /**
       * Create a calendar day element
       * @param {number} day - Day number
       * @param {Array<string>} classes - Additional CSS class modifiers
       * @returns {HTMLElement} Day element
       */
      createDayElement(day, classes = []) {
        const el = document.createElement('div');
        el.className = 'datetime-picker__day';
        classes.forEach(cls => {
          el.classList.add(`datetime-picker__day--${cls}`);
        });
        el.textContent = day;
        return el;
      },

      /**
       * Handle date selection from calendar
       * @param {Date} date - Selected date
       */
      selectDate(date) {
        console.log('[DateTimePicker] Date selected:', date.toDateString());

        // Single date selection - set range to entire day
        const start = date.getTime();
        const end = start + 86400000 - 1;

        // Clamp to data range
        const clampedStart = Math.max(start, this.dataRange.start || start);
        const clampedEnd = Math.min(end, this.dataRange.end || end);

        State.set('time.start', clampedStart);
        State.set('time.end', clampedEnd);
        State.set('time.current', clampedStart);

        // Update UI
        TimeSlider.updateLabels(clampedStart, clampedEnd);
        TimeController.updateClock(clampedStart);
        EventBus.emit('filter:update');

        this.updateTriggerText();
        this.updatePresetButtons('');
        this.renderCalendar();
      },

      /**
       * Handle preset button clicks
       * @param {string} preset - Preset identifier
       */
      handlePreset(preset) {
        console.log('[DateTimePicker] Applying preset:', preset);
        this.updatePresetButtons(preset);

        const now = Date.now();
        let start, end;

        switch (preset) {
          case 'today':
            start = new Date().setHours(0, 0, 0, 0);
            end = start + 86400000 - 1;
            break;

          case 'yesterday':
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            start = yesterday.setHours(0, 0, 0, 0);
            end = start + 86400000 - 1;
            break;

          case '7days':
            end = now;
            start = end - (7 * 86400000);
            break;

          case '30days':
            end = now;
            start = end - (30 * 86400000);
            break;

          case 'thisMonth':
            const firstOfMonth = new Date();
            firstOfMonth.setDate(1);
            firstOfMonth.setHours(0, 0, 0, 0);
            start = firstOfMonth.getTime();
            end = new Date(firstOfMonth.getFullYear(), firstOfMonth.getMonth() + 1, 0, 23, 59, 59, 999).getTime();
            break;

          case 'all':
          default:
            start = this.dataRange.start;
            end = this.dataRange.end;
            break;
        }

        // Clamp to data range
        if (this.dataRange.start && this.dataRange.end) {
          start = Math.max(start, this.dataRange.start);
          end = Math.min(end, this.dataRange.end);
        }

        State.set('time.start', start);
        State.set('time.end', end);
        State.set('time.current', start);

        // Update UI
        TimeSlider.updateLabels(start, end);
        TimeController.updateClock(start);
        EventBus.emit('filter:update');

        this.updateTriggerText();
        this.renderCalendar();
      },

      /**
       * Update preset button active states
       * @param {string} active - Active preset identifier (or empty string)
       */
      updatePresetButtons(active) {
        document.querySelectorAll('.datetime-picker__preset').forEach(btn => {
          const isActive = btn.dataset.preset === active;
          btn.classList.toggle('datetime-picker__preset--active', isActive);
        });
      },

      /**
       * Update the trigger button text to show selected range
       */
      updateTriggerText() {
        const start = State.get('time.start');
        const end = State.get('time.end');
        const textEl = document.getElementById('dateTimePickerText');

        if (!textEl) return;

        if (!start || !end) {
          textEl.textContent = 'Select Range';
          return;
        }

        const startDate = new Date(start);
        const endDate = new Date(end);

        const formatShort = (d) => d.toLocaleDateString('en-US', {
          month: 'short',
          day: 'numeric'
        });

        // Same day
        if (startDate.toDateString() === endDate.toDateString()) {
          textEl.textContent = formatShort(startDate);
        } else {
          textEl.textContent = `${formatShort(startDate)} - ${formatShort(endDate)}`;
        }
      }
    };

    // ============================================================
    // MODULE: Application Bootstrap
    // Initializes all modules and starts the application
    // Could be extracted to: js/main.js
    // ============================================================
    async function initializeApp() {
      console.log('[App] Starting initialization...');

      const loadingText = document.querySelector('.loading-text');
      const loadingSubtext = document.querySelector('.loading-subtext');

      try {
        // Phase 1: Initialize theme
        if (loadingText) loadingText.textContent = 'Loading Theme System';
        if (loadingSubtext) loadingSubtext.textContent = 'Initializing preferences...';
        ThemeController.init();

        // Phase 2: Initialize time controls
        if (loadingText) loadingText.textContent = 'Loading Time Controls';
        if (loadingSubtext) loadingSubtext.textContent = 'Initializing playback system...';
        TimeController.init();
        TimeSlider.init();

        // Phase 3: Initialize filters
        if (loadingText) loadingText.textContent = 'Loading Filters';
        if (loadingSubtext) loadingSubtext.textContent = 'Initializing contact filter...';
        ContactFilter.init();
        DateTimePicker.init();

        // Phase 4: Initialize map
        if (loadingText) loadingText.textContent = 'Loading Map';
        if (loadingSubtext) loadingSubtext.textContent = 'Initializing Mapbox GL JS...';
        await MapController.init();

        // Map is ready - update status
        if (loadingText) loadingText.textContent = 'Map Ready';
        if (loadingSubtext) loadingSubtext.textContent = 'Visualization loaded successfully';

        // If we have embedded data, load it
        if (window.BANDICOOT_DATA && window.BANDICOOT_DATA.features) {
          if (loadingText) loadingText.textContent = 'Loading Data';
          if (loadingSubtext) loadingSubtext.textContent = `Processing ${window.BANDICOOT_DATA.features.length} events...`;

          // Small delay to show the message
          await new Promise(resolve => setTimeout(resolve, 300));

          // Process data through DataLoader
          const processedData = DataLoader.process(window.BANDICOOT_DATA);

          if (processedData) {
            // Load data into map
            MapController.loadData(window.BANDICOOT_DATA);

            // Emit data loaded event for time controllers
            EventBus.emit('data:loaded', processedData);
          }
        }

        // Hide loading overlay
        setTimeout(() => {
          const overlay = document.getElementById('loadingOverlay');
          if (overlay) {
            overlay.classList.add('loading-overlay--hidden');
          }
        }, 500);

        console.log('[App] Initialization complete');

      } catch (error) {
        console.error('[App] Initialization failed:', error);

        if (loadingText) {
          loadingText.textContent = 'Initialization Failed';
          loadingText.style.color = 'var(--accent-secondary)';
        }

        if (loadingSubtext) {
          loadingSubtext.textContent = error.message || 'Unknown error occurred';
        }
      }
    }

    // ============================================================
    // DATA: Embedded GeoJSON
    // This will be populated by the Python generation script
    // or with sample data for testing
    // IMPORTANT: This must run BEFORE initializeApp() is called
    // ============================================================
    window.BANDICOOT_DATA = null; // Will be set to {{GEOJSON_DATA}} by generator

    // ============================================================
    // SAMPLE DATA: For demonstration purposes
    // Generate sample CDR events if no data is provided
    // Creates realistic patterns: work hours, frequent contacts, clustered locations
    // IMPORTANT: This must run BEFORE initializeApp() is called
    // ============================================================
    (function() {
      // Only generate sample data if BANDICOOT_DATA is null
      if (window.BANDICOOT_DATA !== null) return;

      console.log('[SampleData] Generating enhanced demo data...');

      const features = [];

      // Contacts with varying communication frequency (realistic distribution)
      const contacts = [
        { id: 'Alice', weight: 25 },     // Primary contact - most frequent
        { id: 'Bob', weight: 20 },       // Close friend
        { id: 'Charlie', weight: 15 },   // Work colleague
        { id: 'Diana', weight: 12 },     // Family member
        { id: 'Eve', weight: 10 },       // Acquaintance
        { id: 'Frank', weight: 8 },      // Occasional contact
        { id: 'Grace', weight: 6 },      // Rare contact
        { id: 'Henry', weight: 4 }       // Very rare
      ];
      const totalWeight = contacts.reduce((sum, c) => sum + c.weight, 0);

      // Weighted random contact selection
      function getWeightedContact() {
        let random = Math.random() * totalWeight;
        for (const contact of contacts) {
          random -= contact.weight;
          if (random <= 0) return contact.id;
        }
        return contacts[0].id;
      }

      // Location clusters (realistic movement patterns)
      const locations = [
        { name: 'Home', lat: 37.7749, lng: -122.4194, weight: 35, radius: 0.002 },
        { name: 'Work', lat: 37.7849, lng: -122.4094, weight: 30, radius: 0.003 },
        { name: 'Downtown', lat: 37.7899, lng: -122.4044, weight: 15, radius: 0.008 },
        { name: 'Park', lat: 37.7699, lng: -122.4244, weight: 10, radius: 0.004 },
        { name: 'Shopping', lat: 37.7649, lng: -122.4344, weight: 10, radius: 0.005 }
      ];
      const totalLocWeight = locations.reduce((sum, l) => sum + l.weight, 0);

      // Weighted random location selection
      function getWeightedLocation() {
        let random = Math.random() * totalLocWeight;
        for (const loc of locations) {
          random -= loc.weight;
          if (random <= 0) return loc;
        }
        return locations[0];
      }

      // Generate events over the past 14 days
      const now = Date.now();
      const startTime = now - (14 * 24 * 60 * 60 * 1000);
      const eventCount = 350; // More events for better demo

      for (let i = 0; i < eventCount; i++) {
        // Distribute events with realistic hourly patterns
        // More activity during 8am-10pm, less at night
        let timestamp = startTime + Math.random() * (now - startTime);
        const hour = new Date(timestamp).getHours();

        // Reduce night events (11pm - 7am)
        if (hour >= 23 || hour < 7) {
          if (Math.random() > 0.15) {
            timestamp = new Date(timestamp).setHours(8 + Math.floor(Math.random() * 14));
          }
        }

        const contact = getWeightedContact();
        const location = getWeightedLocation();

        // Calls more common with close contacts, texts more common overall
        const isCloseContact = ['Alice', 'Bob', 'Diana'].includes(contact);
        const type = isCloseContact ? (Math.random() < 0.45 ? 'call' : 'text') : (Math.random() < 0.25 ? 'call' : 'text');

        // Incoming slightly more common than outgoing
        const direction = Math.random() < 0.55 ? 'in' : 'out';

        // Location with slight randomness within cluster radius
        const lat = location.lat + (Math.random() - 0.5) * location.radius * 2;
        const lng = location.lng + (Math.random() - 0.5) * location.radius * 2;

        // Call durations: short (< 1min), medium (1-5min), long (5-15min)
        let duration = null;
        if (type === 'call') {
          const durationClass = Math.random();
          if (durationClass < 0.3) duration = Math.floor(Math.random() * 60) + 10;       // Short
          else if (durationClass < 0.75) duration = Math.floor(Math.random() * 240) + 60; // Medium
          else duration = Math.floor(Math.random() * 600) + 300;                          // Long
        }

        features.push({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: [lng, lat]
          },
          properties: {
            timestamp: timestamp,
            interaction_type: type,
            direction: direction,
            correspondent_id: contact,
            duration: duration,
            antenna_id: `ANT-${location.name.substring(0, 3).toUpperCase()}-${Math.floor(Math.random() * 10)}`
          }
        });
      }

      // Sort by timestamp for proper timeline
      features.sort((a, b) => a.properties.timestamp - b.properties.timestamp);

      window.BANDICOOT_DATA = {
        type: 'FeatureCollection',
        features: features
      };

      console.log('[SampleData] Generated', features.length, 'enhanced sample events');
    })();

    // Start the application when DOM is ready
    // IMPORTANT: This must run AFTER sample data generation
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }

  </script>
</body>
</html>
